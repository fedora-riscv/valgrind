diff -ur valgrind-3.15.0.orig/coregrind/m_syswrap/priv_syswrap-linux.h valgrind-3.15.0/coregrind/m_syswrap/priv_syswrap-linux.h
--- valgrind-3.15.0.orig/coregrind/m_syswrap/priv_syswrap-linux.h	2020-02-28 14:02:29.841341757 +0100
+++ valgrind-3.15.0/coregrind/m_syswrap/priv_syswrap-linux.h	2020-02-28 14:55:44.622692816 +0100
@@ -388,6 +388,28 @@
 DECL_TEMPLATE(linux, sys_kcmp);
 DECL_TEMPLATE(linux, sys_copy_file_range);
 
+/* 64bit time_t syscalls for 32bit arches.  */
+DECL_TEMPLATE(linux, sys_clock_gettime64)
+DECL_TEMPLATE(linux, sys_clock_settime64)
+// clock_adjtime64
+DECL_TEMPLATE(linux, sys_clock_getres_time64)
+DECL_TEMPLATE(linux, sys_clock_nanosleep_time64);
+DECL_TEMPLATE(linux, sys_timer_gettime64);
+DECL_TEMPLATE(linux, sys_timer_settime64);
+DECL_TEMPLATE(linux, sys_timerfd_gettime64);
+DECL_TEMPLATE(linux, sys_timerfd_settime64);
+DECL_TEMPLATE(linux, sys_utimensat_time64);
+DECL_TEMPLATE(linux, sys_pselect6_time64);
+DECL_TEMPLATE(linux, sys_ppoll_time64);
+// io_pgetevents_time64
+DECL_TEMPLATE(linux, sys_recvmmsg_time64);
+DECL_TEMPLATE(linux, sys_mq_timedsend_time64);
+DECL_TEMPLATE(linux, sys_mq_timedreceive_time64);
+DECL_TEMPLATE(linux, sys_semtimedop_time64);
+DECL_TEMPLATE(linux, sys_rt_sigtimedwait_time64);
+DECL_TEMPLATE(linux, sys_futex_time64);
+DECL_TEMPLATE(linux, sys_sched_rr_get_interval_time64);
+
 // Some arch specific functions called from syswrap-linux.c
 extern Int do_syscall_clone_x86_linux ( Word (*fn)(void *), 
                                         void* stack, 
diff -ur valgrind-3.15.0.orig/coregrind/m_syswrap/syswrap-arm-linux.c valgrind-3.15.0/coregrind/m_syswrap/syswrap-arm-linux.c
--- valgrind-3.15.0.orig/coregrind/m_syswrap/syswrap-arm-linux.c	2020-02-28 14:02:29.848341656 +0100
+++ valgrind-3.15.0/coregrind/m_syswrap/syswrap-arm-linux.c	2020-02-28 14:55:44.623692804 +0100
@@ -744,7 +744,7 @@
    LINX_(__NR_sched_get_priority_max, sys_sched_get_priority_max),// 159
 
    LINX_(__NR_sched_get_priority_min, sys_sched_get_priority_min),// 160
-//zz    //LINX?(__NR_sched_rr_get_interval,  sys_sched_rr_get_interval), // 161 */*
+   LINXY(__NR_sched_rr_get_interval,  sys_sched_rr_get_interval), // 161
    GENXY(__NR_nanosleep,         sys_nanosleep),      // 162
    GENX_(__NR_mremap,            sys_mremap),         // 163
    LINX_(__NR_setresuid,         sys_setresuid16),    // 164
@@ -1020,6 +1020,28 @@
    LINX_(__NR_copy_file_range,   sys_copy_file_range),  // 391
 
    LINXY(__NR_statx,             sys_statx),            // 397
+
+   LINXY(__NR_clock_gettime64,   sys_clock_gettime64),  // 403
+   LINX_(__NR_clock_settime64,   sys_clock_settime64),  // 404
+
+   LINXY(__NR_clock_getres_time64, sys_clock_getres_time64), // 406
+   LINXY(__NR_clock_nanosleep_time64, sys_clock_nanosleep_time64), // 407
+   LINXY(__NR_timer_gettime64,   sys_timer_gettime64),  // 408
+   LINXY(__NR_timer_settime64,   sys_timer_settime64),  // 409
+   LINXY(__NR_timerfd_gettime64, sys_timerfd_gettime64),// 410
+   LINXY(__NR_timerfd_settime64, sys_timerfd_settime64),// 411
+   LINX_(__NR_utimensat_time64,  sys_utimensat_time64), // 412
+   LINXY(__NR_pselect6_time64,   sys_pselect6_time64),  // 413
+   LINXY(__NR_ppoll_time64,      sys_ppoll_time64),     // 414
+
+   LINXY(__NR_recvmmsg_time64,   sys_recvmmsg_time64),  // 417
+   LINX_(__NR_mq_timedsend_time64, sys_mq_timedsend_time64), // 418
+   LINXY(__NR_mq_timedreceive_time64, sys_mq_timedreceive_time64), // 419
+   LINX_(__NR_semtimedop_time64, sys_semtimedop_time64),// 420
+   LINXY(__NR_rt_sigtimedwait_time64, sys_rt_sigtimedwait_time64), // 421
+   LINXY(__NR_futex_time64,      sys_futex_time64),     // 422
+   LINXY(__NR_sched_rr_get_interval_time64,
+         sys_sched_rr_get_interval_time64),             // 423
 };
 
 
diff -ur valgrind-3.15.0.orig/coregrind/m_syswrap/syswrap-linux.c valgrind-3.15.0/coregrind/m_syswrap/syswrap-linux.c
--- valgrind-3.15.0.orig/coregrind/m_syswrap/syswrap-linux.c	2020-02-28 14:02:29.843341728 +0100
+++ valgrind-3.15.0/coregrind/m_syswrap/syswrap-linux.c	2020-02-28 14:55:44.625692781 +0100
@@ -1584,7 +1584,9 @@
    }
 }
 
-PRE(sys_futex)
+static void futex_pre_helper ( ThreadId tid, SyscallArgLayout* layout,
+                               SyscallArgs* arrghs, SyscallStatus* status,
+                               UWord* flags, Bool is_time64 )
 {
    /* 
       arg    param                              used by ops
@@ -1596,21 +1598,32 @@
       ARG5 - u32 *uaddr2			REQUEUE,CMP_REQUEUE
       ARG6 - int val3				CMP_REQUEUE
     */
-   PRINT("sys_futex ( %#" FMT_REGWORD "x, %ld, %ld, %#" FMT_REGWORD
-         "x, %#" FMT_REGWORD "x )", ARG1, SARG2, SARG3, ARG4, ARG5);
+
    switch(ARG2 & ~(VKI_FUTEX_PRIVATE_FLAG|VKI_FUTEX_CLOCK_REALTIME)) {
    case VKI_FUTEX_CMP_REQUEUE:
    case VKI_FUTEX_WAKE_OP:
    case VKI_FUTEX_CMP_REQUEUE_PI:
-      PRE_REG_READ6(long, "futex", 
-                    vki_u32 *, futex, int, op, int, val,
-                    struct timespec *, utime, vki_u32 *, uaddr2, int, val3);
+      if (is_time64) {
+         PRE_REG_READ6(long, "futex_time64", 
+                       vki_u32 *, futex, int, op, int, val,
+                       struct timespec64 *, utime, vki_u32 *, uaddr2, int, val3);
+      } else {
+         PRE_REG_READ6(long, "futex", 
+                       vki_u32 *, futex, int, op, int, val,
+                       struct timespec *, utime, vki_u32 *, uaddr2, int, val3);
+      }
       break;
    case VKI_FUTEX_REQUEUE:
    case VKI_FUTEX_WAIT_REQUEUE_PI:
-      PRE_REG_READ5(long, "futex", 
-                    vki_u32 *, futex, int, op, int, val,
-                    struct timespec *, utime, vki_u32 *, uaddr2);
+      if (is_time64) {
+         PRE_REG_READ5(long, "futex_time64", 
+                       vki_u32 *, futex, int, op, int, val,
+                       struct timespec64 *, utime, vki_u32 *, uaddr2);
+      } else {
+         PRE_REG_READ5(long, "futex", 
+                       vki_u32 *, futex, int, op, int, val,
+                       struct timespec *, utime, vki_u32 *, uaddr2);
+      }
       break;
    case VKI_FUTEX_WAIT_BITSET:
       /* Check that the address at least begins in client-accessible area. */
@@ -1619,15 +1632,27 @@
             return;
       }
       if (*(vki_u32 *)(Addr)ARG1 != ARG3) {
-         PRE_REG_READ4(long, "futex",
-                       vki_u32 *, futex, int, op, int, val,
-                       struct timespec *, utime);
+         if (is_time64) {
+            PRE_REG_READ4(long, "futex_time64",
+                          vki_u32 *, futex, int, op, int, val,
+                          struct timespec64 *, utime);
+         } else {
+            PRE_REG_READ4(long, "futex",
+                          vki_u32 *, futex, int, op, int, val,
+                          struct timespec64 *, utime);
+         }
       } else {
         /* Note argument 5 is unused, but argument 6 is used.
            So we cannot just PRE_REG_READ6. Read argument 6 separately.  */
-         PRE_REG_READ4(long, "futex",
-                       vki_u32 *, futex, int, op, int, val,
-                       struct timespec *, utime);
+         if (is_time64) {
+            PRE_REG_READ4(long, "futex_time64",
+                          vki_u32 *, futex, int, op, int, val,
+                          struct timespec64 *, utime);
+         } else {
+            PRE_REG_READ4(long, "futex",
+                          vki_u32 *, futex, int, op, int, val,
+                          struct timespec *, utime);
+         }
          if (VG_(tdict).track_pre_reg_read)
             PRA6("futex",int,val3);
       }
@@ -1641,9 +1666,15 @@
       break;
    case VKI_FUTEX_WAIT:
    case VKI_FUTEX_LOCK_PI:
-      PRE_REG_READ4(long, "futex", 
-                    vki_u32 *, futex, int, op, int, val,
-                    struct timespec *, utime);
+      if (is_time64) {
+         PRE_REG_READ4(long, "futex_time64", 
+                       vki_u32 *, futex, int, op, int, val,
+                       struct timespec64 *, utime);
+      } else {
+         PRE_REG_READ4(long, "futex", 
+                       vki_u32 *, futex, int, op, int, val,
+                       struct timespec *, utime);
+      }
       break;
    case VKI_FUTEX_WAKE:
    case VKI_FUTEX_FD:
@@ -1665,8 +1696,15 @@
    case VKI_FUTEX_WAIT_BITSET:
    case VKI_FUTEX_WAIT_REQUEUE_PI:
       PRE_MEM_READ( "futex(futex)", ARG1, sizeof(Int) );
-      if (ARG4 != 0)
-	 PRE_MEM_READ( "futex(timeout)", ARG4, sizeof(struct vki_timespec) );
+      if (ARG4 != 0) {
+         if (is_time64) {
+	    PRE_MEM_READ( "futex_time64(timeout)", ARG4,
+                          sizeof(struct vki_timespec64) );
+         } else {
+	    PRE_MEM_READ( "futex(timeout)", ARG4,
+                          sizeof(struct vki_timespec) );
+         }
+      }
       break;
 
    case VKI_FUTEX_REQUEUE:
@@ -1690,7 +1728,9 @@
       break;
    }
 }
-POST(sys_futex)
+
+static void futex_post_helper ( ThreadId tid, SyscallArgs* arrghs,
+                                SyscallStatus* status )
 {
    vg_assert(SUCCESS);
    POST_MEM_WRITE( ARG1, sizeof(int) );
@@ -1705,6 +1745,30 @@
    }
 }
 
+PRE(sys_futex)
+{
+   PRINT("sys_futex ( %#" FMT_REGWORD "x, %ld, %ld, %#" FMT_REGWORD
+         "x, %#" FMT_REGWORD "x )", ARG1, SARG2, SARG3, ARG4, ARG5);
+   futex_pre_helper (tid, layout, arrghs, status, flags, False);
+}
+
+POST(sys_futex)
+{
+  futex_post_helper (tid, arrghs, status);
+}
+
+PRE(sys_futex_time64)
+{
+   PRINT("sys_futex_time64 ( %#" FMT_REGWORD "x, %ld, %ld, %#" FMT_REGWORD
+         "x, %#" FMT_REGWORD "x )", ARG1, SARG2, SARG3, ARG4, ARG5);
+   futex_pre_helper (tid, layout, arrghs, status, flags, True);
+}
+
+POST(sys_futex_time64)
+{
+  futex_post_helper (tid, arrghs, status);
+}
+
 PRE(sys_set_robust_list)
 {
    PRINT("sys_set_robust_list ( %#" FMT_REGWORD "x, %"
@@ -1747,16 +1811,22 @@
     vki_sigset_t adjusted_ss;
 };
 
-PRE(sys_pselect6)
+static void pselect6_pre_helper ( ThreadId tid, SyscallArgLayout* layout,
+                                  SyscallArgs* arrghs, SyscallStatus* status,
+                                  UWord* flags, Bool is_time64 )
 {
    *flags |= SfMayBlock | SfPostOnFail;
-   PRINT("sys_pselect6 ( %ld, %#" FMT_REGWORD "x, %#" FMT_REGWORD "x, %#"
-         FMT_REGWORD "x, %#" FMT_REGWORD "x, %#" FMT_REGWORD "x )",
-         SARG1, ARG2, ARG3, ARG4, ARG5, ARG6);
-   PRE_REG_READ6(long, "pselect6",
-                 int, n, vki_fd_set *, readfds, vki_fd_set *, writefds,
-                 vki_fd_set *, exceptfds, struct vki_timeval *, timeout,
-                 void *, sig);
+   if (is_time64) {
+      PRE_REG_READ6(long, "pselect6_time64",
+                    int, n, vki_fd_set *, readfds, vki_fd_set *, writefds,
+                    vki_fd_set *, exceptfds, struct vki_timespec64 *, timeout,
+                    void *, sig);
+   } else {
+      PRE_REG_READ6(long, "pselect6",
+                    int, n, vki_fd_set *, readfds, vki_fd_set *, writefds,
+                    vki_fd_set *, exceptfds, struct vki_timespec *, timeout,
+                    void *, sig);
+   }
    // XXX: this possibly understates how much memory is read.
    if (ARG2 != 0)
       PRE_MEM_READ( "pselect6(readfds)",   
@@ -1767,8 +1837,15 @@
    if (ARG4 != 0)
       PRE_MEM_READ( "pselect6(exceptfds)", 
 		     ARG4, ARG1/8 /* __FD_SETSIZE/8 */ );
-   if (ARG5 != 0)
-      PRE_MEM_READ( "pselect6(timeout)", ARG5, sizeof(struct vki_timeval) );
+   if (ARG5 != 0) {
+      if (is_time64) {
+         PRE_MEM_READ( "pselect6_time64(timeout)", ARG5,
+                       sizeof(struct vki_timespec64) );
+      } else {
+         PRE_MEM_READ( "pselect6(timeout)", ARG5,
+                       sizeof(struct vki_timespec) );
+      }
+   }
    if (ARG6 != 0) {
       const struct pselect_sized_sigset *pss =
           (struct pselect_sized_sigset *)(Addr)ARG6;
@@ -1796,6 +1873,15 @@
       }
    }
 }
+
+PRE(sys_pselect6)
+{
+   PRINT("sys_pselect6 ( %ld, %#" FMT_REGWORD "x, %#" FMT_REGWORD "x, %#"
+         FMT_REGWORD "x, %#" FMT_REGWORD "x, %#" FMT_REGWORD "x )",
+         SARG1, ARG2, ARG3, ARG4, ARG5, ARG6);
+   pselect6_pre_helper (tid, layout, arrghs, status, flags, False);
+}
+
 POST(sys_pselect6)
 {
    if (ARG6 != 0 && ARG6 != 1) {
@@ -1803,7 +1889,24 @@
    }
 }
 
-PRE(sys_ppoll)
+PRE(sys_pselect6_time64)
+{
+   PRINT("sys_pselect6_time64 ( %ld, %#" FMT_REGWORD "x, %#" FMT_REGWORD "x, %#"
+         FMT_REGWORD "x, %#" FMT_REGWORD "x, %#" FMT_REGWORD "x )",
+         SARG1, ARG2, ARG3, ARG4, ARG5, ARG6);
+   pselect6_pre_helper (tid, layout, arrghs, status, flags, True);
+}
+
+POST(sys_pselect6_time64)
+{
+   if (ARG6 != 0 && ARG6 != 1) {
+       VG_(free)((struct pselect_adjusted_sigset *)(Addr)ARG6);
+   }
+}
+
+static void ppoll_pre_helper ( ThreadId tid, SyscallArgLayout* layout,
+                               SyscallArgs* arrghs, SyscallStatus* status,
+                               UWord* flags, Bool is_time64 )
 {
    UInt i;
    struct vki_pollfd* ufds = (struct vki_pollfd *)(Addr)ARG1;
@@ -1811,10 +1914,17 @@
    PRINT("sys_ppoll ( %#" FMT_REGWORD "x, %" FMT_REGWORD "u, %#" FMT_REGWORD
          "x, %#" FMT_REGWORD "x, %" FMT_REGWORD "u )\n",
          ARG1, ARG2, ARG3, ARG4, ARG5);
-   PRE_REG_READ5(long, "ppoll",
-                 struct vki_pollfd *, ufds, unsigned int, nfds,
-                 struct vki_timespec *, tsp, vki_sigset_t *, sigmask,
-                 vki_size_t, sigsetsize);
+   if (is_time64) {
+      PRE_REG_READ5(long, "ppoll_time64",
+                    struct vki_pollfd *, ufds, unsigned int, nfds,
+                    struct vki_timespec64 *, tsp, vki_sigset_t *, sigmask,
+                    vki_size_t, sigsetsize);
+   } else {
+      PRE_REG_READ5(long, "ppoll",
+                    struct vki_pollfd *, ufds, unsigned int, nfds,
+                    struct vki_timespec *, tsp, vki_sigset_t *, sigmask,
+                    vki_size_t, sigsetsize);
+   }
 
    for (i = 0; i < ARG2; i++) {
       PRE_MEM_READ( "ppoll(ufds.fd)",
@@ -1825,8 +1935,15 @@
                      (Addr)(&ufds[i].revents), sizeof(ufds[i].revents) );
    }
 
-   if (ARG3)
-      PRE_MEM_READ( "ppoll(tsp)", ARG3, sizeof(struct vki_timespec) );
+   if (ARG3) {
+      if (is_time64) {
+         PRE_MEM_READ( "ppoll_time64(tsp)", ARG3,
+                       sizeof(struct vki_timespec64) );
+      } else {
+         PRE_MEM_READ( "ppoll(tsp)", ARG3,
+                       sizeof(struct vki_timespec) );
+      }
+   }
    if (ARG4 != 0 && sizeof(vki_sigset_t) == ARG5) {
       const vki_sigset_t *guest_sigmask = (vki_sigset_t *)(Addr)ARG4;
       PRE_MEM_READ( "ppoll(sigmask)", ARG4, ARG5);
@@ -1842,7 +1959,8 @@
    }
 }
 
-POST(sys_ppoll)
+static void ppoll_post_helper ( ThreadId tid, SyscallArgs* arrghs,
+                                SyscallStatus* status )
 {
    vg_assert(SUCCESS || FAILURE);
    if (SUCCESS && (RES >= 0)) {
@@ -1856,6 +1974,32 @@
    }
 }
 
+PRE(sys_ppoll)
+{
+   PRINT("sys_ppoll ( %#" FMT_REGWORD "x, %" FMT_REGWORD "u, %#" FMT_REGWORD
+         "x, %#" FMT_REGWORD "x, %" FMT_REGWORD "u )\n",
+         ARG1, ARG2, ARG3, ARG4, ARG5);
+   ppoll_pre_helper (tid, layout, arrghs, status, flags, False);
+}
+
+POST(sys_ppoll)
+{
+   ppoll_post_helper (tid, arrghs, status);
+}
+
+PRE(sys_ppoll_time64)
+{
+   PRINT("sys_ppoll_time64 ( %#" FMT_REGWORD "x, %" FMT_REGWORD
+         "u, %#" FMT_REGWORD "x, %#" FMT_REGWORD "x, %" FMT_REGWORD "u )\n",
+         ARG1, ARG2, ARG3, ARG4, ARG5);
+   ppoll_pre_helper (tid, layout, arrghs, status, flags, False);
+}
+
+POST(sys_ppoll_time64)
+{
+   ppoll_post_helper (tid, arrghs, status);
+}
+
 
 /* ---------------------------------------------------------------------
    epoll_* wrappers
@@ -2644,6 +2788,26 @@
    }
 }
 
+PRE(sys_mq_timedsend_time64)
+{
+   *flags |= SfMayBlock;
+   PRINT("sys_mq_timedsend_time64 ( %ld, %#" FMT_REGWORD "x, %" FMT_REGWORD
+         "u, %" FMT_REGWORD "u, %#" FMT_REGWORD "x )",
+         SARG1,ARG2,ARG3,ARG4,ARG5);
+   PRE_REG_READ5(long, "mq_timedsend_time64",
+                 vki_mqd_t, mqdes, const char *, msg_ptr, vki_size_t, msg_len,
+                 unsigned int, msg_prio,
+                 const struct vki_timespec64 *, abs_timeout);
+   if (!ML_(fd_allowed)(ARG1, "mq_timedsend_time64", tid, False)) {
+      SET_STATUS_Failure( VKI_EBADF );
+   } else {
+      PRE_MEM_READ( "mq_timedsend_time64(msg_ptr)", ARG2, ARG3 );
+      if (ARG5 != 0)
+         PRE_MEM_READ( "mq_timedsend_time64(abs_timeout)", ARG5,
+                        sizeof(struct vki_timespec64) );
+   }
+}
+
 PRE(sys_mq_timedreceive)
 {
    *flags |= SfMayBlock;
@@ -2673,6 +2837,36 @@
       POST_MEM_WRITE( ARG4, sizeof(unsigned int) );
 }
 
+PRE(sys_mq_timedreceive_time64)
+{
+   *flags |= SfMayBlock;
+   PRINT("sys_mq_timedreceive_time64( %ld, %#" FMT_REGWORD "x, %"
+         FMT_REGWORD "u, %#" FMT_REGWORD "x, %#" FMT_REGWORD "x )",
+         SARG1,ARG2,ARG3,ARG4,ARG5);
+   PRE_REG_READ5(ssize_t, "mq_timedreceive_time64",
+                 vki_mqd_t, mqdes, char *, msg_ptr, vki_size_t, msg_len,
+                 unsigned int *, msg_prio,
+                 const struct vki_timespec64 *, abs_timeout);
+   if (!ML_(fd_allowed)(ARG1, "mq_timedreceive_time64", tid, False)) {
+      SET_STATUS_Failure( VKI_EBADF );
+   } else {
+      PRE_MEM_WRITE( "mq_timedreceive_time64(msg_ptr)", ARG2, ARG3 );
+      if (ARG4 != 0)
+         PRE_MEM_WRITE( "mq_timedreceive_time64(msg_prio)",
+                        ARG4, sizeof(unsigned int) );
+      if (ARG5 != 0)
+         PRE_MEM_READ( "mq_timedreceive_time64(abs_timeout)",
+                        ARG5, sizeof(struct vki_timespec64) );
+   }
+}
+
+POST(sys_mq_timedreceive_time64)
+{
+   POST_MEM_WRITE( ARG2, RES );
+   if (ARG4 != 0)
+      POST_MEM_WRITE( ARG4, sizeof(unsigned int) );
+}
+
 PRE(sys_mq_notify)
 {
    PRINT("sys_mq_notify( %ld, %#" FMT_REGWORD "x )", SARG1, ARG2 );
@@ -2723,6 +2917,14 @@
    PRE_MEM_READ( "clock_settime(tp)", ARG2, sizeof(struct vki_timespec) );
 }
 
+PRE(sys_clock_settime64)
+{
+   PRINT("sys_clock_settime64( %ld, %#" FMT_REGWORD "x )", SARG1, ARG2);
+   PRE_REG_READ2(long, "clock_settime64",
+                 vki_clockid_t, clk_id, const struct timespec64 *, tp);
+   PRE_MEM_READ( "clock_settime64(tp)", ARG2, sizeof(struct vki_timespec64) );
+}
+
 PRE(sys_clock_gettime)
 {
    PRINT("sys_clock_gettime( %ld, %#" FMT_REGWORD "x )" , SARG1, ARG2);
@@ -2735,6 +2937,18 @@
    POST_MEM_WRITE( ARG2, sizeof(struct vki_timespec) );
 }
 
+PRE(sys_clock_gettime64)
+{
+   PRINT("sys_clock_gettime64( %ld, %#" FMT_REGWORD "x )" , SARG1, ARG2);
+   PRE_REG_READ2(long, "clock_gettime64",
+                 vki_clockid_t, clk_id, struct vki_timespec64 *, tp);
+   PRE_MEM_WRITE( "clock_gettime64(tp)", ARG2, sizeof(struct vki_timespec64) );
+}
+POST(sys_clock_gettime64)
+{
+   POST_MEM_WRITE( ARG2, sizeof(struct vki_timespec64) );
+}
+
 PRE(sys_clock_getres)
 {
    PRINT("sys_clock_getres( %ld, %#" FMT_REGWORD "x )" , SARG1, ARG2);
@@ -2751,6 +2965,23 @@
       POST_MEM_WRITE( ARG2, sizeof(struct vki_timespec) );
 }
 
+PRE(sys_clock_getres_time64)
+{
+   PRINT("sys_clock_getres_time64( %ld, %#" FMT_REGWORD "x )" , SARG1, ARG2);
+   // Nb: we can't use "RES" as the param name because that's a macro
+   // defined above!
+   PRE_REG_READ2(long, "clock_getres_time64",
+                 vki_clockid_t, clk_id, struct vki_timespec64 *, res);
+   if (ARG2 != 0)
+      PRE_MEM_WRITE( "clock_getres_time64(res)", ARG2,
+		     sizeof(struct vki_timespec64) );
+}
+POST(sys_clock_getres_time64)
+{
+   if (ARG2 != 0)
+      POST_MEM_WRITE( ARG2, sizeof(struct vki_timespec64) );
+}
+
 PRE(sys_clock_nanosleep)
 {
    *flags |= SfMayBlock|SfPostOnFail;
@@ -2770,6 +3001,28 @@
       POST_MEM_WRITE( ARG4, sizeof(struct vki_timespec) );
 }
 
+PRE(sys_clock_nanosleep_time64)
+{
+   *flags |= SfMayBlock|SfPostOnFail;
+   PRINT("sys_clock_nanosleep_time64( %ld, %ld, %#" FMT_REGWORD "x, %#"
+         FMT_REGWORD "x )",
+         SARG1, SARG2, ARG3, ARG4);
+   PRE_REG_READ4(int32_t, "clock_nanosleep_time64",
+                 vki_clockid_t, clkid, int, flags,
+                 const struct vki_timespec64 *, rqtp,
+		 struct vki_timespec64 *, rmtp);
+   PRE_MEM_READ( "clock_nanosleep_time64(rqtp)", ARG3,
+		 sizeof(struct vki_timespec64) );
+   if (ARG4 != 0)
+      PRE_MEM_WRITE( "clock_nanosleep_time64(rmtp)", ARG4,
+		     sizeof(struct vki_timespec64) );
+}
+POST(sys_clock_nanosleep_time64)
+{
+   if (ARG4 != 0 && FAILURE && ERR == VKI_EINTR)
+      POST_MEM_WRITE( ARG4, sizeof(struct vki_timespec64) );
+}
+
 /* ---------------------------------------------------------------------
    timer_* wrappers
    ------------------------------------------------------------------ */
@@ -2821,6 +3074,26 @@
       POST_MEM_WRITE( ARG4, sizeof(struct vki_itimerspec) );
 }
 
+PRE(sys_timer_settime64)
+{
+   PRINT("sys_timer_settime64( %ld, %ld, %#" FMT_REGWORD "x, %#"
+          FMT_REGWORD "x )", SARG1,SARG2,ARG3,ARG4);
+   PRE_REG_READ4(long, "timer_settime64", 
+                 vki_timer_t, timerid, int, flags,
+                 const struct vki_itimerspec64 *, value,
+                 struct vki_itimerspec64 *, ovalue);
+   PRE_MEM_READ( "timer_settime64(value)", ARG3,
+                  sizeof(struct vki_itimerspec64) );
+   if (ARG4 != 0)
+       PRE_MEM_WRITE( "timer_settime64(ovalue)", ARG4,
+                      sizeof(struct vki_itimerspec64) );
+}
+POST(sys_timer_settime64)
+{
+   if (ARG4 != 0)
+      POST_MEM_WRITE( ARG4, sizeof(struct vki_itimerspec64) );
+}
+
 PRE(sys_timer_gettime)
 {
    PRINT("sys_timer_gettime( %ld, %#" FMT_REGWORD "x )", SARG1, ARG2);
@@ -2834,6 +3107,19 @@
    POST_MEM_WRITE( ARG2, sizeof(struct vki_itimerspec) );
 }
 
+PRE(sys_timer_gettime64)
+{
+   PRINT("sys_timer_gettime64( %ld, %#" FMT_REGWORD "x )", SARG1, ARG2);
+   PRE_REG_READ2(long, "timer_gettime64", 
+                 vki_timer_t, timerid, struct vki_itimerspec64 *, value);
+   PRE_MEM_WRITE( "timer_gettime64(value)", ARG2,
+                  sizeof(struct vki_itimerspec64));
+}
+POST(sys_timer_gettime64)
+{
+   POST_MEM_WRITE( ARG2, sizeof(struct vki_itimerspec64) );
+}
+
 PRE(sys_timer_getoverrun)
 {
    PRINT("sys_timer_getoverrun( %#" FMT_REGWORD "x )", ARG1);
@@ -2940,6 +3226,24 @@
       POST_MEM_WRITE(ARG2, sizeof(struct vki_itimerspec));
 }
 
+PRE(sys_timerfd_gettime64)
+{
+   PRINT("sys_timerfd_gettime64 ( %ld, %#" FMT_REGWORD "x )", SARG1, ARG2);
+   PRE_REG_READ2(long, "timerfd_gettime64",
+                 int, ufd,
+                 struct vki_itimerspec64*, otmr);
+   if (!ML_(fd_allowed)(ARG1, "timerfd_gettime64", tid, False))
+      SET_STATUS_Failure(VKI_EBADF);
+   else
+      PRE_MEM_WRITE("timerfd_gettime64(result)",
+                    ARG2, sizeof(struct vki_itimerspec64));
+}
+POST(sys_timerfd_gettime64)
+{
+   if (RES == 0)
+      POST_MEM_WRITE(ARG2, sizeof(struct vki_itimerspec64));
+}
+
 PRE(sys_timerfd_settime)
 {
    PRINT("sys_timerfd_settime ( %ld, %ld, %#" FMT_REGWORD "x, %#"
@@ -2968,6 +3272,34 @@
       POST_MEM_WRITE(ARG4, sizeof(struct vki_itimerspec));
 }
 
+PRE(sys_timerfd_settime64)
+{
+   PRINT("sys_timerfd_settime64 ( %ld, %ld, %#" FMT_REGWORD "x, %#"
+         FMT_REGWORD "x )", SARG1, SARG2, ARG3, ARG4);
+   PRE_REG_READ4(long, "timerfd_settime64",
+                 int, ufd,
+                 int, flags,
+                 const struct vki_itimerspec64*, utmr,
+                 struct vki_itimerspec64*, otmr);
+   if (!ML_(fd_allowed)(ARG1, "timerfd_settime64", tid, False))
+      SET_STATUS_Failure(VKI_EBADF);
+   else
+   {
+      PRE_MEM_READ("timerfd_settime64(result)",
+                   ARG3, sizeof(struct vki_itimerspec64));
+      if (ARG4)
+      {
+         PRE_MEM_WRITE("timerfd_settime64(result)",
+                       ARG4, sizeof(struct vki_itimerspec64));
+      }
+   }
+}
+POST(sys_timerfd_settime64)
+{
+   if (RES == 0 && ARG4 != 0)
+      POST_MEM_WRITE(ARG4, sizeof(struct vki_itimerspec64));
+}
+
 /* ---------------------------------------------------------------------
    capabilities wrappers
    ------------------------------------------------------------------ */
@@ -3350,6 +3682,22 @@
    POST_MEM_WRITE(ARG2, sizeof(struct vki_timespec));
 }
 
+PRE(sys_sched_rr_get_interval_time64)
+{
+   PRINT("sys_sched_rr_get_interval_time64 ( %ld, %#" FMT_REGWORD "x )",
+         SARG1, ARG2);
+   PRE_REG_READ2(int, "sched_rr_get_interval_time64",
+                 vki_pid_t, pid,
+                 struct vki_timespec *, tp);
+   PRE_MEM_WRITE("sched_rr_get_interval_time64(timespec)",
+                 ARG2, sizeof(struct vki_timespec64));
+}
+
+POST(sys_sched_rr_get_interval_time64)
+{
+   POST_MEM_WRITE(ARG2, sizeof(struct vki_timespec64));
+}
+
 PRE(sys_sched_setaffinity)
 {
    PRINT("sched_setaffinity ( %ld, %" FMT_REGWORD "u, %#" FMT_REGWORD "x )",
@@ -4067,6 +4415,31 @@
       POST_MEM_WRITE( ARG2, sizeof(vki_siginfo_t) );
 }
 
+PRE(sys_rt_sigtimedwait_time64)
+{
+   *flags |= SfMayBlock;
+   PRINT("sys_rt_sigtimedwait_time64 ( %#" FMT_REGWORD "x, %#"
+         FMT_REGWORD "x, %#" FMT_REGWORD "x, %" FMT_REGWORD "u )",
+         ARG1, ARG2, ARG3, ARG4);
+   PRE_REG_READ4(long, "rt_sigtimedwait_time64", 
+                 const vki_sigset_t *, set, vki_siginfo_t *, info,
+                 const struct vki_timespec64 *, timeout,
+                 vki_size_t, sigsetsize);
+   if (ARG1 != 0) 
+      PRE_MEM_READ( "rt_sigtimedwait_time64(set)", ARG1, sizeof(vki_sigset_t) );
+   if (ARG2 != 0)
+      PRE_MEM_WRITE( "rt_sigtimedwait_time64(info)", ARG2,
+                     sizeof(vki_siginfo_t) );
+   if (ARG3 != 0)
+      PRE_MEM_READ( "rt_sigtimedwait_time64(timeout)",
+                    ARG3, sizeof(struct vki_timespec64) );
+}
+POST(sys_rt_sigtimedwait_time64)
+{
+   if (ARG2 != 0)
+      POST_MEM_WRITE( ARG2, sizeof(vki_siginfo_t) );
+}
+
 PRE(sys_rt_sigqueueinfo)
 {
    PRINT("sys_rt_sigqueueinfo(%ld, %ld, %#" FMT_REGWORD "x)",
@@ -4515,6 +4888,21 @@
    ML_(generic_PRE_sys_semtimedop)(tid, ARG1,ARG2,ARG3,ARG4);
 }
 
+PRE(sys_semtimedop_time64)
+{
+   *flags |= SfMayBlock;
+   PRINT("sys_semtimedop_time64 ( %ld, %#" FMT_REGWORD "x, %"
+         FMT_REGWORD "u, %#" FMT_REGWORD "x )", SARG1, ARG2, ARG3, ARG4);
+   PRE_REG_READ4(long, "semtimedop_time64",
+                 int, semid, struct sembuf *, sops, unsigned, nsoops,
+                 struct vki_timespec64 *, timeout);
+   PRE_MEM_READ( "semtimedop_time64(sops)", ARG1,
+                 ARG2 * sizeof(struct vki_sembuf) );
+   if (ARG3 != 0)
+      PRE_MEM_READ( "semtimedop_time64(timeout)", ARG3,
+                    sizeof(struct vki_timespec64) );
+}
+
 PRE(sys_msgget)
 {
    PRINT("sys_msgget ( %ld, %ld )", SARG1, SARG2);
@@ -5324,6 +5712,36 @@
    }
 }
 
+PRE(sys_utimensat_time64)
+{
+   PRINT("sys_utimensat_time64 ( %ld, %#" FMT_REGWORD "x(%s), %#"
+         FMT_REGWORD "x, 0x%" FMT_REGWORD "x )",
+         SARG1, ARG2, (HChar*)(Addr)ARG2, ARG3, ARG4);
+   PRE_REG_READ4(long, "utimensat_time64",
+                 int, dfd, char *, filename, struct timespec *, utimes, int, flags);
+   if (ARG2 != 0)
+      PRE_MEM_RASCIIZ( "utimensat_time64(filename)", ARG2 );
+   if (ARG3 != 0) {
+      /* If timespec.tv_nsec has the special value UTIME_NOW or UTIME_OMIT
+         then the tv_sec field is ignored.  */
+      struct vki_timespec64 *times = (struct vki_timespec64 *)(Addr)ARG3;
+      PRE_MEM_READ( "utimensat_time64(times[0].tv_nsec)",
+                    (Addr)&times[0].tv_nsec, sizeof(times[0].tv_nsec));
+      PRE_MEM_READ( "utimensat_time64(times[1].tv_nsec)",
+                    (Addr)&times[1].tv_nsec, sizeof(times[1].tv_nsec));
+      if (ML_(safe_to_deref)(times, 2 * sizeof(struct vki_timespec64))) {
+         if (times[0].tv_nsec != VKI_UTIME_NOW
+             && times[0].tv_nsec != VKI_UTIME_OMIT)
+            PRE_MEM_READ( "utimensat_time64(times[0].tv_sec)",
+                          (Addr)&times[0].tv_sec, sizeof(times[0].tv_sec));
+         if (times[1].tv_nsec != VKI_UTIME_NOW
+             && times[1].tv_nsec != VKI_UTIME_OMIT)
+            PRE_MEM_READ( "utimensat_time64(times[1].tv_sec)",
+                          (Addr)&times[1].tv_sec, sizeof(times[1].tv_sec));
+      }
+   }
+}
+
 PRE(sys_newfstatat)
 {
    FUSE_COMPATIBLE_MAY_BLOCK();
@@ -5816,6 +6234,34 @@
    ML_(linux_POST_sys_recvmmsg) (tid, RES, ARG1,ARG2,ARG3,ARG4,ARG5);
 }
 
+PRE(sys_recvmmsg_time64)
+{
+   *flags |= SfMayBlock;
+   PRINT("sys_recvmmsg_time64 ( %ld, %#" FMT_REGWORD "x, %ld, %ld, %#"
+         FMT_REGWORD "x )",
+         SARG1, ARG2, SARG3, SARG4, ARG5);
+   PRE_REG_READ5(long, "recvmmsg_time64",
+                 int, s, struct mmsghdr *, mmsg, int, vlen,
+                 int, flags, struct vki_timespec64 *, timeout);
+   struct vki_mmsghdr *mmsg = (struct vki_mmsghdr *)ARG2;
+   HChar name[40];     // large enough
+   UInt i;
+   for (i = 0; i < ARG3; i++) {
+      VG_(sprintf)(name, "mmsg[%u].msg_hdr", i);
+      ML_(generic_PRE_sys_recvmsg)(tid, name, &mmsg[i].msg_hdr);
+      VG_(sprintf)(name, "recvmmsg(mmsg[%u].msg_len)", i);
+      PRE_MEM_WRITE( name, (Addr)&mmsg[i].msg_len, sizeof(mmsg[i].msg_len) );
+   }
+   if (ARG5)
+      PRE_MEM_READ( "recvmmsg(timeout)", ARG5, sizeof(struct vki_timespec64) );
+}
+
+POST(sys_recvmmsg_time64)
+{
+   /* ARG5 isn't actually used, so just use the generic POST. */
+   ML_(linux_POST_sys_recvmmsg) (tid, RES, ARG1,ARG2,ARG3,ARG4,ARG5);
+}
+
 /* ---------------------------------------------------------------------
    key retention service wrappers
    ------------------------------------------------------------------ */
@@ -12312,3 +12758,4 @@
 /*--------------------------------------------------------------------*/
 /*--- end                                                          ---*/
 /*--------------------------------------------------------------------*/
+
diff -ur valgrind-3.15.0.orig/coregrind/m_syswrap/syswrap-mips32-linux.c valgrind-3.15.0/coregrind/m_syswrap/syswrap-mips32-linux.c
--- valgrind-3.15.0.orig/coregrind/m_syswrap/syswrap-mips32-linux.c	2019-04-13 12:56:21.000000000 +0200
+++ valgrind-3.15.0/coregrind/m_syswrap/syswrap-mips32-linux.c	2020-02-28 15:48:55.507851274 +0100
@@ -1066,7 +1066,29 @@
    //..
    LINX_(__NR_membarrier,              sys_membarrier),              // 358
    //..
-   LINXY(__NR_statx,                   sys_statx)                    // 366
+   LINXY(__NR_statx,                   sys_statx),                   // 366
+
+   LINXY(__NR_clock_gettime64,         sys_clock_gettime64),         // 403
+   LINX_(__NR_clock_settime64,         sys_clock_settime64),         // 404
+
+   LINXY(__NR_clock_getres_time64,     sys_clock_getres_time64),     // 406
+   LINXY(__NR_clock_nanosleep_time64,  sys_clock_nanosleep_time64),  // 407
+   LINXY(__NR_timer_gettime64,         sys_timer_gettime64),         // 408
+   LINXY(__NR_timer_settime64,         sys_timer_settime64),         // 409
+   LINXY(__NR_timerfd_gettime64,       sys_timerfd_gettime64),       // 410
+   LINXY(__NR_timerfd_settime64,       sys_timerfd_settime64),       // 411
+   LINX_(__NR_utimensat_time64,        sys_utimensat_time64),        // 412
+   LINXY(__NR_pselect6_time64,         sys_pselect6_time64),         // 413
+   LINXY(__NR_ppoll_time64,            sys_ppoll_time64),            // 414
+
+   LINXY(__NR_recvmmsg_time64,         sys_recvmmsg_time64),         // 417
+   LINX_(__NR_mq_timedsend_time64,     sys_mq_timedsend_time64),     // 418
+   LINXY(__NR_mq_timedreceive_time64,  sys_mq_timedreceive_time64),  // 419
+   LINX_(__NR_semtimedop_time64,       sys_semtimedop_time64),       // 420
+   LINXY(__NR_rt_sigtimedwait_time64,  sys_rt_sigtimedwait_time64),  // 421
+   LINXY(__NR_futex_time64,            sys_futex_time64),            // 422
+   LINXY(__NR_sched_rr_get_interval_time64,
+         sys_sched_rr_get_interval_time64),                          // 423
 };
 
 SyscallTableEntry* ML_(get_linux_syscall_entry) (UInt sysno)
diff -ur valgrind-3.15.0.orig/coregrind/m_syswrap/syswrap-ppc32-linux.c valgrind-3.15.0/coregrind/m_syswrap/syswrap-ppc32-linux.c
--- valgrind-3.15.0.orig/coregrind/m_syswrap/syswrap-ppc32-linux.c	2020-02-28 14:02:29.809342221 +0100
+++ valgrind-3.15.0/coregrind/m_syswrap/syswrap-ppc32-linux.c	2020-02-28 14:55:44.626692770 +0100
@@ -1024,6 +1024,28 @@
    LINX_(__NR_copy_file_range,   sys_copy_file_range),  // 379
 
    LINXY(__NR_statx,             sys_statx),            // 383
+
+   LINXY(__NR_clock_gettime64,   sys_clock_gettime64),  // 403
+   LINX_(__NR_clock_settime64,   sys_clock_settime64),  // 404
+
+   LINXY(__NR_clock_getres_time64, sys_clock_getres_time64), // 406
+   LINXY(__NR_clock_nanosleep_time64, sys_clock_nanosleep_time64), // 407
+   LINXY(__NR_timer_gettime64,   sys_timer_gettime64),  // 408
+   LINXY(__NR_timer_settime64,   sys_timer_settime64),  // 409
+   LINXY(__NR_timerfd_gettime64, sys_timerfd_gettime64),// 410
+   LINXY(__NR_timerfd_settime64, sys_timerfd_settime64),// 411
+   LINX_(__NR_utimensat_time64,  sys_utimensat_time64), // 412
+   LINXY(__NR_pselect6_time64,   sys_pselect6_time64),  // 413
+   LINXY(__NR_ppoll_time64,      sys_ppoll_time64),     // 414
+
+   LINXY(__NR_recvmmsg_time64,   sys_recvmmsg_time64),  // 417
+   LINX_(__NR_mq_timedsend_time64, sys_mq_timedsend_time64), // 418
+   LINXY(__NR_mq_timedreceive_time64, sys_mq_timedreceive_time64), // 419
+   LINX_(__NR_semtimedop_time64, sys_semtimedop_time64),// 420
+   LINXY(__NR_rt_sigtimedwait_time64, sys_rt_sigtimedwait_time64), // 421
+   LINXY(__NR_futex_time64,      sys_futex_time64),     // 422
+   LINXY(__NR_sched_rr_get_interval_time64,
+         sys_sched_rr_get_interval_time64),             // 423
 };
 
 SyscallTableEntry* ML_(get_linux_syscall_entry) ( UInt sysno )
diff -ur valgrind-3.15.0.orig/coregrind/m_syswrap/syswrap-x86-linux.c valgrind-3.15.0/coregrind/m_syswrap/syswrap-x86-linux.c
--- valgrind-3.15.0.orig/coregrind/m_syswrap/syswrap-x86-linux.c	2020-02-28 14:02:29.844341714 +0100
+++ valgrind-3.15.0/coregrind/m_syswrap/syswrap-x86-linux.c	2020-02-28 15:44:37.688691592 +0100
@@ -1618,7 +1618,30 @@
    LINXY(__NR_statx,             sys_statx),            // 383
 
    /* Explicitly not supported on i386 yet. */
-   GENX_(__NR_arch_prctl,        sys_ni_syscall)        // 384
+   GENX_(__NR_arch_prctl,        sys_ni_syscall),       // 384
+
+   LINXY(__NR_clock_gettime64,   sys_clock_gettime64),  // 403
+   LINX_(__NR_clock_settime64,   sys_clock_settime64),  // 404
+
+   LINXY(__NR_clock_getres_time64, sys_clock_getres_time64), // 406
+   LINXY(__NR_clock_nanosleep_time64, sys_clock_nanosleep_time64), // 407
+   LINXY(__NR_timer_gettime64,   sys_timer_gettime64),  // 408
+   LINXY(__NR_timer_settime64,   sys_timer_settime64),  // 409
+   LINXY(__NR_timerfd_gettime64, sys_timerfd_gettime64),// 410
+   LINXY(__NR_timerfd_settime64, sys_timerfd_settime64),// 411
+   LINX_(__NR_utimensat_time64,  sys_utimensat_time64), // 412
+   LINXY(__NR_pselect6_time64,   sys_pselect6_time64),  // 413
+   LINXY(__NR_ppoll_time64,      sys_ppoll_time64),     // 414
+
+   LINXY(__NR_recvmmsg_time64,   sys_recvmmsg_time64),  // 417
+   LINX_(__NR_mq_timedsend_time64, sys_mq_timedsend_time64), // 418
+   LINXY(__NR_mq_timedreceive_time64, sys_mq_timedreceive_time64), // 419
+   LINX_(__NR_semtimedop_time64, sys_semtimedop_time64),// 420
+   LINXY(__NR_rt_sigtimedwait_time64, sys_rt_sigtimedwait_time64), // 421
+   LINXY(__NR_futex_time64,      sys_futex_time64),     // 422
+   LINXY(__NR_sched_rr_get_interval_time64,
+         sys_sched_rr_get_interval_time64),             // 423
+
 };
 
 SyscallTableEntry* ML_(get_linux_syscall_entry) ( UInt sysno )
diff -ur valgrind-3.15.0.orig/include/pub_tool_vkiscnums_asm.h valgrind-3.15.0/include/pub_tool_vkiscnums_asm.h
--- valgrind-3.15.0.orig/include/pub_tool_vkiscnums_asm.h	2019-04-13 12:56:21.000000000 +0200
+++ valgrind-3.15.0/include/pub_tool_vkiscnums_asm.h	2020-02-28 14:55:44.627692759 +0100
@@ -34,30 +34,43 @@
 #define __PUB_TOOL_VKISCNUMS_ASM_H
 
 #if defined(VGP_x86_linux)
+#  include "vki/vki-scnums-shared-linux.h"
+#  include "vki/vki-scnums-32bit-linux.h"
 #  include "vki/vki-scnums-x86-linux.h"
 
 #elif defined(VGP_amd64_linux)
+#  include "vki/vki-scnums-shared-linux.h"
 #  include "vki/vki-scnums-amd64-linux.h"
 
 #elif defined(VGP_ppc32_linux)
+#  include "vki/vki-scnums-shared-linux.h"
+#  include "vki/vki-scnums-32bit-linux.h"
 #  include "vki/vki-scnums-ppc32-linux.h"
 
 #elif defined(VGP_ppc64be_linux) || defined(VGP_ppc64le_linux)
+#  include "vki/vki-scnums-shared-linux.h"
 #  include "vki/vki-scnums-ppc64-linux.h"
 
 #elif defined(VGP_s390x_linux)
+#  include "vki/vki-scnums-shared-linux.h"
 #  include "vki/vki-scnums-s390x-linux.h"
 
 #elif defined(VGP_arm_linux)
+#  include "vki/vki-scnums-shared-linux.h"
+#  include "vki/vki-scnums-32bit-linux.h"
 #  include "vki/vki-scnums-arm-linux.h"
 
 #elif defined(VGP_arm64_linux)
+#  include "vki/vki-scnums-shared-linux.h"
 #  include "vki/vki-scnums-arm64-linux.h"
 
 #elif defined(VGP_mips32_linux)
+#  include "vki/vki-scnums-shared-linux.h"
+#  include "vki/vki-scnums-32bit-linux.h"
 #  include "vki/vki-scnums-mips32-linux.h"
 
 #elif defined(VGP_mips64_linux)
+#  include "vki/vki-scnums-shared-linux.h"
 #  include "vki/vki-scnums-mips64-linux.h"
 
 #elif defined(VGP_x86_darwin) || defined(VGP_amd64_darwin)
diff -ur valgrind-3.15.0.orig/include/vki/vki-linux.h valgrind-3.15.0/include/vki/vki-linux.h
--- valgrind-3.15.0.orig/include/vki/vki-linux.h	2020-02-28 14:02:29.873341294 +0100
+++ valgrind-3.15.0/include/vki/vki-linux.h	2020-02-28 14:55:44.627692759 +0100
@@ -5130,6 +5130,20 @@
 	__vki_u32 id;
 } __attribute__((aligned(8)));
 
+/* Needed for 64bit time_t on 32bit arches.  */
+
+typedef vki_int64_t vki_time64_t;
+
+struct vki_timespec64 {
+   vki_time64_t tv_sec;
+   long tv_nsec;
+};
+
+struct vki_itimerspec64 {
+   struct vki_timespec it_interval;
+   struct vki_timespec it_value;
+};
+
 /*--------------------------------------------------------------------*/
 /*--- end                                                          ---*/
 /*--------------------------------------------------------------------*/
Only in valgrind-3.15.0/include/vki: vki-scnums-32bit-linux.h
diff -ur valgrind-3.15.0.orig/include/vki/vki-scnums-amd64-linux.h valgrind-3.15.0/include/vki/vki-scnums-amd64-linux.h
--- valgrind-3.15.0.orig/include/vki/vki-scnums-amd64-linux.h	2019-04-13 12:56:21.000000000 +0200
+++ valgrind-3.15.0/include/vki/vki-scnums-amd64-linux.h	2020-02-28 14:55:44.628692747 +0100
@@ -32,7 +32,7 @@
 #ifndef __VKI_SCNUMS_AMD64_LINUX_H
 #define __VKI_SCNUMS_AMD64_LINUX_H
 
-// Derived from linux-2.6/arch/x86/entry/syscalls/syscall_64.tbl
+// Derived from linux-5.2/arch/x86/entry/syscalls/syscall_64.tbl
 
 #define __NR_read                                0
 #define __NR_write                               1
@@ -414,6 +414,8 @@
 #define __NR_pkey_alloc         330
 #define __NR_pkey_free          331
 #define __NR_statx              332
+#define __NR_io_pgetevents	333
+#define __NR_rseq		334
 
 #endif /* __VKI_SCNUMS_AMD64_LINUX_H */
 
Only in valgrind-3.15.0/include/vki: vki-scnums-shared-linux.h
diff -ur valgrind-3.15.0.orig/include/vki/vki-scnums-x86-linux.h valgrind-3.15.0/include/vki/vki-scnums-x86-linux.h
--- valgrind-3.15.0.orig/include/vki/vki-scnums-x86-linux.h	2019-04-13 12:56:21.000000000 +0200
+++ valgrind-3.15.0/include/vki/vki-scnums-x86-linux.h	2020-02-28 14:55:44.628692747 +0100
@@ -32,7 +32,7 @@
 #ifndef __VKI_SCNUMS_X86_LINUX_H
 #define __VKI_SCNUMS_X86_LINUX_H
 
-// Derived from linux-2.6/arch/x86/entry/syscalls/syscall_32.tbl
+// Derived from linux-5.2/arch/x86/entry/syscalls/syscall_32.tbl
 
 #define __NR_restart_syscall      0
 #define __NR_exit		  1
@@ -419,6 +419,18 @@
 #define __NR_pkey_free          382
 #define __NR_statx              383
 #define __NR_arch_prctl         384
+#define __NR_io_pgetevents	385
+#define __NR_rseq		386
+#define __NR_semget		393
+#define __NR_semctl		394
+#define __NR_shmget		395
+#define __NR_shmctl		396
+#define __NR_shmat		397
+#define __NR_shmdt		398
+#define __NR_msgget		399
+#define __NR_msgsnd		400
+#define __NR_msgrcv		401
+#define __NR_msgctl		402
 
 #endif /* __VKI_SCNUMS_X86_LINUX_H */
 
diff --git a/include/vki/vki-scnums-32bit-linux.h b/include/vki/vki-scnums-32bit-linux.h
new file mode 100644
index 000000000..f276ddaed
--- /dev/null
+++ b/include/vki/vki-scnums-32bit-linux.h
@@ -0,0 +1,49 @@
+/*
+   This file is part of Valgrind, a dynamic binary instrumentation framework.
+
+   Copyright (C) 2019 Bart Van Assche <bvanassche@acm.org>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#ifndef __VKI_SCNUMS_32BIT_LINUX_H
+#define __VKI_SCNUMS_32BIT_LINUX_H
+
+// Derived from the __BITS_PER_LONG == 32 sections in
+// linux-5.2/include/uapi/asm-generic/unistd.h
+
+#define __NR_clock_gettime64	403
+#define __NR_clock_settime64	404
+#define __NR_clock_adjtime64	405
+#define __NR_clock_getres_time64	406
+#define __NR_clock_nanosleep_time64	407
+#define __NR_timer_gettime64	408
+#define __NR_timer_settime64	409
+#define __NR_timerfd_gettime64	410
+#define __NR_timerfd_settime64	411
+#define __NR_utimensat_time64	412
+#define __NR_pselect6_time64	413
+#define __NR_ppoll_time64	414
+#define __NR_io_pgetevents_time64	416
+#define __NR_recvmmsg_time64	417
+#define __NR_mq_timedsend_time64	418
+#define __NR_mq_timedreceive_time64	419
+#define __NR_semtimedop_time64	420
+#define __NR_rt_sigtimedwait_time64	421
+#define __NR_futex_time64	422
+#define __NR_sched_rr_get_interval_time64	423
+
+#endif
diff --git a/include/vki/vki-scnums-shared-linux.h b/include/vki/vki-scnums-shared-linux.h
new file mode 100644
index 000000000..6221d5a81
--- /dev/null
+++ b/include/vki/vki-scnums-shared-linux.h
@@ -0,0 +1,42 @@
+
+/* System call numbers for Linux that are shared across all architectures. */
+
+/*
+   This file is part of Valgrind, a dynamic binary instrumentation
+   framework.
+
+   Copyright (C) 2019 Bart Van Assche <bvanassche@acm.org>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#ifndef __VKI_SCNUMS_SHARED_LINUX_H
+#define __VKI_SCNUMS_SHARED_LINUX_H
+
+// Derived from linux-5.2/include/uapi/asm-generic/unistd.h
+
+#define __NR_pidfd_send_signal	424
+#define __NR_io_uring_setup	425
+#define __NR_io_uring_enter	426
+#define __NR_io_uring_register	427
+#define __NR_open_tree		428
+#define __NR_move_mount		429
+#define __NR_fsopen		430
+#define __NR_fsconfig		431
+#define __NR_fsmount		432
+#define __NR_fspick		433
+
+#endif
 
diff --git a/coregrind/m_syswrap/syswrap-linux.c b/coregrind/m_syswrap/syswrap-linux.c
index 14b78addb..1190a57d6 100644
--- a/coregrind/m_syswrap/syswrap-linux.c
+++ b/coregrind/m_syswrap/syswrap-linux.c
@@ -1622,6 +1622,20 @@ POST(sys_sendfile64)
    }
 }
 
+static void pre_read_timespec64 (ThreadId tid, const char *msg, UWord arg)
+{
+   struct vki_timespec64 *ts64 = (void *)(Addr)arg;
+   PRE_MEM_READ (msg, (Addr) &ts64->tv_sec, sizeof(vki_time64_t));
+   PRE_MEM_READ (msg, (Addr) &ts64->tv_nsec, sizeof(vki_int32_t));
+}
+
+static void pre_read_itimerspec64 (ThreadId tid, const char *msg, UWord arg)
+{
+   struct vki_itimerspec64 *its64 = (void *)(Addr)arg;
+   pre_read_timespec64 (tid, msg, (UWord) &its64->it_interval);
+   pre_read_timespec64 (tid, msg, (UWord) &its64->it_value);
+}
+
 static void futex_pre_helper ( ThreadId tid, SyscallArgLayout* layout,
                                SyscallArgs* arrghs, SyscallStatus* status,
                                UWord* flags, Bool is_time64 )
@@ -1736,8 +1750,7 @@ static void futex_pre_helper ( ThreadId tid, SyscallArgLayout* layout,
       PRE_MEM_READ( "futex(futex)", ARG1, sizeof(Int) );
       if (ARG4 != 0) {
          if (is_time64) {
-	    PRE_MEM_READ( "futex_time64(timeout)", ARG4,
-                          sizeof(struct vki_timespec64) );
+            pre_read_timespec64 (tid, "futex_time64(timeout)", ARG4);
          } else {
 	    PRE_MEM_READ( "futex(timeout)", ARG4,
                           sizeof(struct vki_timespec) );
@@ -1877,8 +1890,7 @@ static void pselect6_pre_helper ( ThreadId tid, SyscallArgLayout* layout,
 		     ARG4, ARG1/8 /* __FD_SETSIZE/8 */ );
    if (ARG5 != 0) {
       if (is_time64) {
-         PRE_MEM_READ( "pselect6_time64(timeout)", ARG5,
-                       sizeof(struct vki_timespec64) );
+         pre_read_timespec64(tid, "pselect6_time64(timeout)", ARG5);
       } else {
          PRE_MEM_READ( "pselect6(timeout)", ARG5,
                        sizeof(struct vki_timespec) );
@@ -1975,8 +1987,7 @@ static void ppoll_pre_helper ( ThreadId tid, SyscallArgLayout* layout,
 
    if (ARG3) {
       if (is_time64) {
-         PRE_MEM_READ( "ppoll_time64(tsp)", ARG3,
-                       sizeof(struct vki_timespec64) );
+         pre_read_timespec64(tid, "ppoll_time64(tsp)", ARG3);
       } else {
          PRE_MEM_READ( "ppoll(tsp)", ARG3,
                        sizeof(struct vki_timespec) );
@@ -2841,8 +2852,7 @@ PRE(sys_mq_timedsend_time64)
    } else {
       PRE_MEM_READ( "mq_timedsend_time64(msg_ptr)", ARG2, ARG3 );
       if (ARG5 != 0)
-         PRE_MEM_READ( "mq_timedsend_time64(abs_timeout)", ARG5,
-                        sizeof(struct vki_timespec64) );
+         pre_read_timespec64(tid, "mq_timedsend_time64(abs_timeout)", ARG5);
    }
 }
 
@@ -2893,8 +2903,7 @@ PRE(sys_mq_timedreceive_time64)
          PRE_MEM_WRITE( "mq_timedreceive_time64(msg_prio)",
                         ARG4, sizeof(unsigned int) );
       if (ARG5 != 0)
-         PRE_MEM_READ( "mq_timedreceive_time64(abs_timeout)",
-                        ARG5, sizeof(struct vki_timespec64) );
+         pre_read_timespec64(tid, "mq_timedreceive_time64(abs_timeout)", ARG5);
    }
 }
 
@@ -2960,7 +2969,7 @@ PRE(sys_clock_settime64)
    PRINT("sys_clock_settime64( %ld, %#" FMT_REGWORD "x )", SARG1, ARG2);
    PRE_REG_READ2(long, "clock_settime64",
                  vki_clockid_t, clk_id, const struct timespec64 *, tp);
-   PRE_MEM_READ( "clock_settime64(tp)", ARG2, sizeof(struct vki_timespec64) );
+   pre_read_timespec64(tid, "clock_settime64(tp)", ARG2);
 }
 
 PRE(sys_clock_gettime)
@@ -2980,7 +2989,8 @@ PRE(sys_clock_gettime64)
    PRINT("sys_clock_gettime64( %ld, %#" FMT_REGWORD "x )" , SARG1, ARG2);
    PRE_REG_READ2(long, "clock_gettime64",
                  vki_clockid_t, clk_id, struct vki_timespec64 *, tp);
-   PRE_MEM_WRITE( "clock_gettime64(tp)", ARG2, sizeof(struct vki_timespec64) );
+   PRE_MEM_WRITE ( "clock_gettime64(tp)", ARG2,
+                   sizeof(struct vki_timespec64) );
 }
 POST(sys_clock_gettime64)
 {
@@ -3012,7 +3022,7 @@ PRE(sys_clock_getres_time64)
                  vki_clockid_t, clk_id, struct vki_timespec64 *, res);
    if (ARG2 != 0)
       PRE_MEM_WRITE( "clock_getres_time64(res)", ARG2,
-		     sizeof(struct vki_timespec64) );
+                     sizeof(struct vki_timespec64) );
 }
 POST(sys_clock_getres_time64)
 {
@@ -3049,8 +3059,7 @@ PRE(sys_clock_nanosleep_time64)
                  vki_clockid_t, clkid, int, flags,
                  const struct vki_timespec64 *, rqtp,
 		 struct vki_timespec64 *, rmtp);
-   PRE_MEM_READ( "clock_nanosleep_time64(rqtp)", ARG3,
-		 sizeof(struct vki_timespec64) );
+   pre_read_timespec64(tid, "clock_nanosleep_time64(rqtp)", ARG3);
    if (ARG4 != 0)
       PRE_MEM_WRITE( "clock_nanosleep_time64(rmtp)", ARG4,
 		     sizeof(struct vki_timespec64) );
@@ -3323,8 +3332,7 @@ PRE(sys_timerfd_settime64)
       SET_STATUS_Failure(VKI_EBADF);
    else
    {
-      PRE_MEM_READ("timerfd_settime64(result)",
-                   ARG3, sizeof(struct vki_itimerspec64));
+      pre_read_itimerspec64 (tid, "timerfd_settime64(result)", ARG3);
       if (ARG4)
       {
          PRE_MEM_WRITE("timerfd_settime64(result)",
@@ -4479,8 +4487,7 @@ PRE(sys_rt_sigtimedwait_time64)
       PRE_MEM_WRITE( "rt_sigtimedwait_time64(info)", ARG2,
                      sizeof(vki_siginfo_t) );
    if (ARG3 != 0)
-      PRE_MEM_READ( "rt_sigtimedwait_time64(timeout)",
-                    ARG3, sizeof(struct vki_timespec64) );
+      pre_read_timespec64(tid, "rt_sigtimedwait_time64(timeout)", ARG3);
 }
 POST(sys_rt_sigtimedwait_time64)
 {
@@ -4947,8 +4954,7 @@ PRE(sys_semtimedop_time64)
    PRE_MEM_READ( "semtimedop_time64(sops)", ARG1,
                  ARG2 * sizeof(struct vki_sembuf) );
    if (ARG3 != 0)
-      PRE_MEM_READ( "semtimedop_time64(timeout)", ARG3,
-                    sizeof(struct vki_timespec64) );
+      pre_read_timespec64(tid, "semtimedop_time64(timeout)", ARG3);
 }
 
 PRE(sys_msgget)
@@ -6303,7 +6309,7 @@ PRE(sys_recvmmsg_time64)
       PRE_MEM_WRITE( name, (Addr)&mmsg[i].msg_len, sizeof(mmsg[i].msg_len) );
    }
    if (ARG5)
-      PRE_MEM_READ( "recvmmsg(timeout)", ARG5, sizeof(struct vki_timespec64) );
+      pre_read_timespec64(tid, "recvmmsg(timeout)", ARG5);
 }
 
 POST(sys_recvmmsg_time64)
diff --git a/include/vki/vki-linux.h b/include/vki/vki-linux.h
index 6f42b3822..3d9dabc86 100644
--- a/include/vki/vki-linux.h
+++ b/include/vki/vki-linux.h
@@ -5317,9 +5317,21 @@ struct vki_ptp_pin_desc {
 
 typedef vki_int64_t vki_time64_t;
 
+/* Note that this is the padding used by glibc, the kernel uses
+   a 64-bit signed int, but is ignoring the upper 32 bits of the
+   tv_nsec field.  It does always write the full struct though.
+   So this is only needed for PRE_MEM_READ. See pre_read_timespec64. */
 struct vki_timespec64 {
    vki_time64_t tv_sec;
-   long tv_nsec;
+#if defined(VKI_BIG_ENDIAN)
+   vki_int32_t tv_pad;
+   vki_int32_t tv_nsec;
+#elif defined(VKI_LITTLE_ENDIAN)
+   vki_int32_t tv_nsec;
+   vki_int32_t tv_pad;
+#else
+#error edit for your odd byteorder.
+#endif
 };
 
 struct vki_itimerspec64 {
