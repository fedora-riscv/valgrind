commit 60ff013998de8aa168e01b7b1c1743bcbdee99b1
Author: Will Schmidt <will_schmidt@vnet.ibm.com>
Date:   Thu Aug 12 15:41:50 2021 -0500

    Hi
    
      This reworks the modulo operation as seen in
    valgrind/none/tests/ppc64/test_isa_3_1_common.c:
    initialize_source_registers().   Due to a GCC issue (PR101882), we
    will try to avoid a modulo operation with both input and outputs set to
    a hard register.
      In this case, we can apply the modulo operation to the args[] array
    value used to initialize the ra value.

diff --git a/none/tests/ppc64/test_isa_3_1_common.c b/none/tests/ppc64/test_isa_3_1_common.c
index 8222a857fc..7c3dc6f009 100644
--- a/none/tests/ppc64/test_isa_3_1_common.c
+++ b/none/tests/ppc64/test_isa_3_1_common.c
@@ -2261,12 +2261,17 @@ void initialize_source_registers () {
       if (has_rb)  rb = 2*vrbi;
       /* note special case for is_insert_double, see set_up_iterators () */
       if (has_ra)  ra = 4*vrai;
       if (is_insert_double) {
 	 /* For an insert_double, the results are undefined
-	    for ra > 8, so modulo those into a valid range. */
-	 ra = ra % 9;
+	    for ra > 8, so modulo those into a valid range.
+	    Since ra is defined as a hard register, and due to gcc
+	    issue (PR101882) where a modulo operation fails with
+	    both input and output regs set to a hard register, this
+	    assignment references the args[] array again, versus
+	    ra = ra % 9;.  */
+	 ra = args[vrai] % 9;
       }
    }
 
    if (uses_buffer) {
       if (has_rb) {
