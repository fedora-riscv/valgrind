--- valgrind-3.3.0/VEX/priv/guest-ppc/toIR.c.jj	2007-12-11 00:18:52.000000000 +0100
+++ valgrind-3.3.0/VEX/priv/guest-ppc/toIR.c	2008-03-03 09:58:59.000000000 +0100
@@ -333,6 +333,7 @@ typedef enum {
 } PPC_GST;
 
 #define MASK_FPSCR_RN   0x3
+#define MASK_FPSCR_FPRF 0x1F000
 #define MASK_VSCR_VALID 0x00010001
 
 
@@ -2142,7 +2143,7 @@ static IRExpr* /* ::Ity_I32 */ getGST_ma
 
       /* We're only keeping track of the rounding mode,
          so if the mask isn't asking for this, just return 0x0 */
-      if (mask & 0x3) {
+      if (mask & (MASK_FPSCR_RN|MASK_FPSCR_FPRF)) {
          assign( val, IRExpr_Get( OFFB_FPROUND, Ity_I32 ) );
       } else {
          assign( val, mkU32(0x0) );
@@ -2271,7 +2272,7 @@ static void putGST_masked ( PPC_GST reg,
    switch (reg) {
    case PPC_GST_FPSCR: {
       /* Allow writes to Rounding Mode */
-      if (mask & 0x3) {
+      if (mask & (MASK_FPSCR_RN|MASK_FPSCR_FPRF)) {
          /* construct new fpround from new and old values as per mask:
             new fpround = (src & (3 & mask)) | (fpround & (3 & ~mask)) */
          stmt( 
@@ -2279,11 +2280,11 @@ static void putGST_masked ( PPC_GST reg,
                OFFB_FPROUND,
                binop(
                   Iop_Or32, 
-                  binop(Iop_And32, src, mkU32(3 & mask)),
+                  binop(Iop_And32, src, mkU32((MASK_FPSCR_RN|MASK_FPSCR_FPRF) & mask)),
                   binop(
                      Iop_And32, 
                      IRExpr_Get(OFFB_FPROUND,Ity_I32),
-                     mkU32(3 & ~mask)
+                     mkU32((MASK_FPSCR_RN|MASK_FPSCR_FPRF) & ~mask)
                   )
                )
             )
@@ -3224,6 +3225,48 @@ static Bool dis_int_logic ( UInt theInst
          // TODO: alternatively: assign(rA, verbose_Clz64(rS));
          break;
 
+      case 0x1FC: // cmpb (Power6: compare bytes)
+         DIP("cmpb r%u,r%u,r%u\n", rA_addr, rS_addr, rB_addr);
+	 
+	 if (mode64) 
+	    assign( rA, unop( Iop_V128to64,
+		binop( Iop_CmpEQ8x16,
+		binop( Iop_64HLtoV128, mkU64(0), mkexpr(rS) ),
+		binop( Iop_64HLtoV128, mkU64(0), mkexpr(rB) )
+		)) );
+	 else
+	    assign( rA, unop( Iop_V128to32,
+		binop( Iop_CmpEQ8x16,
+		unop( Iop_32UtoV128, mkexpr(rS) ),
+		unop( Iop_32UtoV128, mkexpr(rB) )
+		)) );
+	 break;
+
+      case 0x2DF: { // mftgpr (move floating-point to general purpose register)
+	 IRTemp frB = newTemp(Ity_F64);
+         DIP("mftgpr r%u,fr%u\n", rS_addr, rB_addr);
+
+	 assign( frB, getFReg(rB_addr));  // always F64
+	 if (mode64)
+	    assign( rA, unop( Iop_ReinterpF64asI64, mkexpr(frB)) );
+	 else
+	    assign( rA, unop( Iop_64to32, unop( Iop_ReinterpF64asI64, mkexpr(frB))) );
+	    
+	 putIReg( rS_addr, mkexpr(rA));
+         return True;
+         }
+      case 0x25F: { // mffgpr (move floating-point from general purpose register)
+	 IRTemp frA = newTemp(Ity_F64);
+         DIP("mffgpr fr%u,r%u\n", rS_addr, rB_addr);
+
+	 if (mode64)
+	    assign( frA, unop( Iop_ReinterpI64asF64, mkexpr(rB)) );
+	 else
+	    assign( frA, unop( Iop_ReinterpI64asF64, unop( Iop_32Uto64, mkexpr(rB))) );
+	    
+         putFReg( rS_addr, mkexpr(frA));
+         return True;
+	 }
       default:
          vex_printf("dis_int_logic(ppc)(opc2)\n");
          return False;
@@ -6533,6 +6576,45 @@ static Bool dis_fp_round ( UInt theInstr
               binop(Iop_I64toF64, rm, mkexpr(r_tmp64)) );
       break;
 
+   case 0x188: case 0x1A8: case 0x1C8: case 0x1E8: // frin, friz, frip, frim
+      switch(opc2) {
+      case 0x188: // frin (Floating Round to Integer Nearest)
+         DIP("frin%s fr%u,fr%u\n", flag_rC ? ".":"", frD_addr, frB_addr);
+         assign( r_tmp64,
+               binop(Iop_F64toI64, mkU32(Irrm_NEAREST), mkexpr(frB)) );
+         break;
+      case 0x1A8: // friz (Floating Round to Integer Toward Zero)
+         DIP("friz%s fr%u,fr%u\n", flag_rC ? ".":"", frD_addr, frB_addr);
+         assign( r_tmp64,
+               binop(Iop_F64toI64, mkU32(Irrm_ZERO), mkexpr(frB)) );
+         break;
+      case 0x1C8: // frip (Floating Round to Integer Plus)
+         DIP("frip%s fr%u,fr%u\n", flag_rC ? ".":"", frD_addr, frB_addr);
+         assign( r_tmp64,
+               binop(Iop_F64toI64, mkU32(Irrm_PosINF), mkexpr(frB)) );
+         break;
+      case 0x1E8: // frim (Floating Round to Integer Minus)
+         DIP("frim%s fr%u,fr%u\n", flag_rC ? ".":"", frD_addr, frB_addr);
+         assign( r_tmp64,
+               binop(Iop_F64toI64, mkU32(Irrm_NegINF), mkexpr(frB)) );
+         break;
+      }
+
+      /* don't use the rounded integer if frB is outside -9e18..9e18 */
+      /* F64 has only log10(2**52) significant digits anyway */
+      /* need to preserve sign of zero */
+      /*   frD = (fabs(frB) > 9e18) ? frB :
+                 (sign(frB)) ? -fabs((double)r_tmp64) : (double)r_tmp64  */
+      assign( frD, IRExpr_Mux0X( unop( Iop_32to8, binop( Iop_CmpF64,
+          IRExpr_Const(IRConst_F64(9e18)), unop( Iop_AbsF64, mkexpr(frB)))),
+         IRExpr_Mux0X( unop( Iop_32to8, binop( Iop_Shr32, unop( Iop_64HIto32,
+                     unop(Iop_ReinterpF64asI64, mkexpr(frB))), mkU8(31))),
+          binop( Iop_I64toF64, mkU32(0), mkexpr(r_tmp64) ),
+          unop( Iop_NegF64, unop( Iop_AbsF64,
+             binop(Iop_I64toF64, mkU32(0), mkexpr(r_tmp64)) )) ),
+       mkexpr(frB) ));
+      break;
+
    default:
       vex_printf("dis_fp_round(ppc)(opc2)\n");
       return False;
@@ -9139,6 +9221,10 @@ DisResult disInstr_PPC_WRK ( 
       case 0x32E: // fctid
       case 0x32F: // fctidz
       case 0x34E: // fcfid
+      case 0x188: // frin (Power5+)
+      case 0x1A8: // friz (Power5+)
+      case 0x1C8: // frip (Power5+)
+      case 0x1E8: // frim (Power5+)
          if (dis_fp_round(theInstr)) goto decode_success;
          goto decode_failure;
          
@@ -9216,6 +9302,10 @@ DisResult disInstr_PPC_WRK ( 
          if (dis_int_arith( theInstr )) goto decode_success;
          goto decode_failure;
 
+      case 0x1FC:                         // cmpb
+	 if (dis_int_logic( theInstr )) goto decode_success;
+         goto decode_failure;
+
       default:
          break;  // Fall through...
       }
@@ -9234,6 +9324,7 @@ DisResult disInstr_PPC_WRK ( 
       case 0x11C: case 0x3BA: case 0x39A: // eqv,  extsb, extsh
       case 0x1DC: case 0x07C: case 0x1BC: // nand, nor,   or
       case 0x19C: case 0x13C:             // orc,  xor
+      case 0x2DF: case 0x25F:		  // mftgpr, mffgpr
          if (dis_int_logic( theInstr )) goto decode_success;
          goto decode_failure;
 
--- valgrind-3.3.0/none/tests/ppc32/Makefile.am.jj	2007-12-11 00:18:32.000000000 +0100
+++ valgrind-3.3.0/none/tests/ppc32/Makefile.am	2008-03-03 10:00:36.000000000 +0100
@@ -19,13 +19,15 @@ EXTRA_DIST = $(noinst_SCRIPTS) \
 	testVMX.stderr.exp  testVMX.stdout.exp  testVMX.vgtest \
 	twi.stderr.exp twi.stdout.exp twi.vgtest \
 	tw.stderr.exp tw.stdout.exp tw.vgtest \
-	xlc_dbl_u32.stderr.exp xlc_dbl_u32.stdout.exp xlc_dbl_u32.vgtest
+	xlc_dbl_u32.stderr.exp xlc_dbl_u32.stdout.exp xlc_dbl_u32.vgtest \
+	power5+_round.stderr.exp power5+_round.stdout.exp power5+_round.vgtest \
+	power6_bcmp.stderr.exp power6_bcmp.stdout.exp power6_bcmp.vgtest
 
 check_PROGRAMS = \
 	bug129390-ppc32 \
 	bug139050-ppc32 \
 	ldstrev lsw jm-insns mftocrf mcrfs round test_fx test_gx \
-	testVMX twi tw xlc_dbl_u32
+	testVMX twi tw xlc_dbl_u32 power5+_round power6_bcmp
 
 AM_CFLAGS   = $(WERROR) -Winline -Wall -Wshadow -g -I$(top_srcdir)/include \
 		@FLAG_M32@
--- valgrind-3.3.0/none/tests/ppc32/power5+_round.c.jj	2008-03-03 09:58:59.000000000 +0100
+++ valgrind-3.3.0/none/tests/ppc32/power5+_round.c	2008-03-03 09:58:59.000000000 +0100
@@ -0,0 +1,147 @@
+/*  Copyright (C) 2007  Pete Eberlein  eberlein@us.ibm.com
+
+    This program is free software; you can redistribute it and/or
+    modify it under the terms of the GNU General Public License as
+    published by the Free Software Foundation; either version 2 of the
+    License, or (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307, USA.
+
+    The GNU General Public License is contained in the file COPYING.
+*/
+
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <math.h>
+
+#define POS_NORMAL   0x4000
+#define NEG_NORMAL   0x8000
+#define POS_INF      0x5000
+#define NEG_INF      0x9000
+#define POS_ZERO     0x2000
+#define NEG_ZERO     0x12000
+#define POS_DENORMAL 0x14000
+#define NEG_DENORMAL 0x18000
+#define NAN          0x11000
+#define FPRF_MASK    0x1F000
+
+
+int main (int argc, char* argv[]) {
+
+  double inf, neg0, nan;
+  union {
+    double d;
+    struct { unsigned int dummy, dummy2: 15, fprf:17; };
+  } fpscr;
+
+  inf = strtod("inf", NULL);
+  neg0 = copysign(0, -1);
+  nan = strtod("nan", NULL);
+
+
+ /* This set is disabled until fprf is implemented. */
+ if (0) {  
+  double set[] = {inf, 1.5, 0, neg0, -1.5, -inf, nan};
+  int i, j, fprf;
+  for (i=0; i<7; ++i) {
+   for (j=0; j<7; ++j) {
+    asm ("fcmpu 1, %1, %2\n\t" \
+         "mffs %0\n" \
+    : "=f" (fpscr.d) \
+    : "f" (set[i]), "f" (set[j]) \
+    );
+
+    if (i == 6 || j == 6) {
+      fprf = 0x1000; // Unordered
+    } else if (i == j || (i==2 && j==3) || (i==3 && j==2)) {
+      fprf = 0x2000; // Equal
+    } else if (i < j) {
+      fprf = 0x4000; // Greater Than
+    } else if (i > j) {
+      fprf = 0x8000; // Less Than
+    }
+
+    printf("fcmpu\t%.1f\t%.1f\t%x\t%s\n", set[i], set[j], fpscr.fprf,
+                                   fpscr.fprf == fprf ? "PASS" : "FAIL");
+   }
+  }
+ }
+
+ {
+  double set[]  = {inf, 1.9, 1.1, 0, neg0, -1.1, -1.9, -inf, nan};
+  double frin[] = {inf, 2.0, 1.0, 0, neg0, -1.0, -2.0, -inf, nan};
+  double friz[] = {inf, 1.0, 1.0, 0, neg0, -1.0, -1.0, -inf, nan};
+  double frip[] = {inf, 2.0, 2.0, 0, neg0, -1.0, -1.0, -inf, nan};
+  double frim[] = {inf, 1.0, 1.0, 0, neg0, -2.0, -2.0, -inf, nan};
+  int fprf[] = {POS_INF, POS_NORMAL, POS_NORMAL, POS_ZERO, NEG_ZERO, 
+                NEG_NORMAL, NEG_NORMAL, NEG_INF, NAN};
+  double set2[]  = {0.9, 0.1, -0.1, -0.9, 1e-40, -1e-40};
+  double frin2[] = {1.0, 0.0, -0.0, -1.0, 0.0,   -0.0};
+  int frin2rf[]  = {POS_NORMAL,POS_ZERO,NEG_ZERO,NEG_NORMAL,POS_ZERO,NEG_ZERO};
+  double friz2[] = {0.0, 0.0, -0.0, -0.0, 0.0,   -0.0};
+  int friz2rf[]  = {POS_ZERO,POS_ZERO,NEG_ZERO,NEG_ZERO,POS_ZERO,NEG_ZERO};
+  double frip2[] = {1.0, 1.0, -0.0, -0.0, 1.0,   -0.0};
+  int frip2rf[]  = {POS_NORMAL,POS_NORMAL,NEG_ZERO,NEG_ZERO,POS_NORMAL,NEG_ZERO};
+  double frim2[] = {0.0, 0.0, -1.0, -1.0, 0.0,   -1.0};
+  int frim2rf[]  = {POS_ZERO,POS_ZERO,NEG_NORMAL,NEG_NORMAL,POS_ZERO,NEG_NORMAL};
+  double ret;
+  int i;
+
+#define DO_TEST(op,in,out,rf)  for (i=0; i<sizeof(in)/sizeof(double); ++i) { \
+    asm (#op" %0, %2\n\t" \
+       "mffs %1\n" \
+    : "=f" (ret), "=f" (fpscr.d) \
+    : "f" (in[i]) \
+    ); \
+    printf(#op"\t%g\t%g\t%x\t%s\n", in[i], ret, fpscr.fprf, \
+           (!bcmp(&ret, &out[i], sizeof(double))) /*&& (rf[i] == fpscr.fprf)*/ \
+	   ? "PASS" : "FAIL"); \
+  }
+  /* Note: fprf check above is disabled until fprf is implemented. */
+
+
+  DO_TEST(frin,set, frin, fprf);
+  DO_TEST(frin,set2,frin2,frin2rf);
+  DO_TEST(friz,set, friz, fprf);
+  DO_TEST(friz,set2,friz2,friz2rf);
+  DO_TEST(frip,set, frip, fprf);
+  DO_TEST(frip,set2,frip2,frip2rf);
+  DO_TEST(frim,set, frim, fprf);
+  DO_TEST(frim,set2,frim2,frim2rf);
+ }
+
+ /* This set is disabled until fprf is implemented. */
+ if (0) { 
+  double set1[]    = {inf, 0.9, 0.1, 0, neg0, -0.1, -0.9, -inf, nan};
+  double frsp1[]   = {inf, 0.9f,0.1f,0, neg0, -0.1f,-0.9f,-inf, nan};
+  int fprf1[] = {POS_INF, POS_NORMAL, POS_NORMAL, POS_ZERO, NEG_ZERO, NEG_NORMAL,
+                NEG_NORMAL, NEG_INF, NAN};
+  double set2[]    = {1.2e-38, 1.1e-38, 1e-40, 8e-44, 9e-44, 8e-46, 7e-46};
+  double frsp2[]   = {1.2e-38f,1.1e-38f,1e-40f,8e-44f,9e-44f,8e-46f,0.0};
+  int fprf2[] = {POS_NORMAL, POS_DENORMAL, POS_DENORMAL, POS_DENORMAL, 
+                POS_DENORMAL, POS_DENORMAL, POS_ZERO};
+  double set3[]    = {-1.2e-38, -1.1e-38, -1e-40, -8e-44, -9e-44, -8e-46, -7e-46};
+  double frsp3[]   = {-1.2e-38f,-1.1e-38f,-1e-40f,-8e-44f,-9e-44f,-8e-46f,-0.0};
+  int fprf3[] = {NEG_NORMAL, NEG_DENORMAL, NEG_DENORMAL, NEG_DENORMAL, 
+                NEG_DENORMAL, NEG_DENORMAL, NEG_ZERO};
+  double ret;
+  int i;
+  DO_TEST(frsp,set1,frsp1,fprf1);
+  DO_TEST(frsp,set2,frsp2,fprf2);
+  DO_TEST(frsp,set3,frsp3,fprf3);
+ }
+
+
+ return 0;
+}
--- valgrind-3.3.0/none/tests/ppc32/power5+_round.stderr.exp.jj	2008-03-03 09:58:59.000000000 +0100
+++ valgrind-3.3.0/none/tests/ppc32/power5+_round.stderr.exp	2008-03-03 09:58:59.000000000 +0100
@@ -0,0 +1,2 @@
+
+
--- valgrind-3.3.0/none/tests/ppc32/power5+_round.stdout.exp.jj	2008-03-03 09:58:59.000000000 +0100
+++ valgrind-3.3.0/none/tests/ppc32/power5+_round.stdout.exp	2008-03-03 09:58:59.000000000 +0100
@@ -0,0 +1,60 @@
+frin	inf	inf	0	PASS
+frin	1.9	2	0	PASS
+frin	1.1	1	0	PASS
+frin	0	0	0	PASS
+frin	-0	-0	0	PASS
+frin	-1.1	-1	0	PASS
+frin	-1.9	-2	0	PASS
+frin	-inf	-inf	0	PASS
+frin	nan	nan	0	PASS
+frin	0.9	1	0	PASS
+frin	0.1	0	0	PASS
+frin	-0.1	-0	0	PASS
+frin	-0.9	-1	0	PASS
+frin	1e-40	0	0	PASS
+frin	-1e-40	-0	0	PASS
+friz	inf	inf	0	PASS
+friz	1.9	1	0	PASS
+friz	1.1	1	0	PASS
+friz	0	0	0	PASS
+friz	-0	-0	0	PASS
+friz	-1.1	-1	0	PASS
+friz	-1.9	-1	0	PASS
+friz	-inf	-inf	0	PASS
+friz	nan	nan	0	PASS
+friz	0.9	0	0	PASS
+friz	0.1	0	0	PASS
+friz	-0.1	-0	0	PASS
+friz	-0.9	-0	0	PASS
+friz	1e-40	0	0	PASS
+friz	-1e-40	-0	0	PASS
+frip	inf	inf	0	PASS
+frip	1.9	2	0	PASS
+frip	1.1	2	0	PASS
+frip	0	0	0	PASS
+frip	-0	-0	0	PASS
+frip	-1.1	-1	0	PASS
+frip	-1.9	-1	0	PASS
+frip	-inf	-inf	0	PASS
+frip	nan	nan	0	PASS
+frip	0.9	1	0	PASS
+frip	0.1	1	0	PASS
+frip	-0.1	-0	0	PASS
+frip	-0.9	-0	0	PASS
+frip	1e-40	1	0	PASS
+frip	-1e-40	-0	0	PASS
+frim	inf	inf	0	PASS
+frim	1.9	1	0	PASS
+frim	1.1	1	0	PASS
+frim	0	0	0	PASS
+frim	-0	-0	0	PASS
+frim	-1.1	-2	0	PASS
+frim	-1.9	-2	0	PASS
+frim	-inf	-inf	0	PASS
+frim	nan	nan	0	PASS
+frim	0.9	0	0	PASS
+frim	0.1	0	0	PASS
+frim	-0.1	-1	0	PASS
+frim	-0.9	-1	0	PASS
+frim	1e-40	0	0	PASS
+frim	-1e-40	-1	0	PASS
--- valgrind-3.3.0/none/tests/ppc32/power5+_round.vgtest.jj	2008-03-03 09:58:59.000000000 +0100
+++ valgrind-3.3.0/none/tests/ppc32/power5+_round.vgtest	2008-03-03 09:58:59.000000000 +0100
@@ -0,0 +1 @@
+prog: power5+_round
--- valgrind-3.3.0/none/tests/ppc32/power6_bcmp.c.jj	2008-03-03 09:58:59.000000000 +0100
+++ valgrind-3.3.0/none/tests/ppc32/power6_bcmp.c	2008-03-03 09:58:59.000000000 +0100
@@ -0,0 +1,58 @@
+/*  Copyright (C) 2007  Pete Eberlein  eberlein@us.ibm.com
+
+    This program is free software; you can redistribute it and/or
+    modify it under the terms of the GNU General Public License as
+    published by the Free Software Foundation; either version 2 of the
+    License, or (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307, USA.
+
+    The GNU General Public License is contained in the file COPYING.
+*/
+
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+
+#define CMPB(result,a,b) \
+    asm __volatile ("cmpb %0, %1, %2\n" : "=r"(result) : "r"(a), "r"(b))
+
+
+int main (int argc, char* argv[]) {
+  int i,j,k;
+  long mask;
+  for (i=1; i<16; i++) {
+   mask = 0;
+   if(i&1) mask+=0xff;
+   if(i&2) mask+=0xff00;
+   if(i&4) mask+=0xff0000;
+   if(i&8) mask+=0xff000000;
+
+   for (j=0; j<256; j++)
+    for (k=0; k<256; k++)
+      if (j!=k) {
+
+    long a, b, result;
+    a = (mask & (j*0x1010101)) + ((~mask) & (k*0x1010101));
+    b = j*0x1010101;
+    CMPB(result, a, b);
+    if (result != mask)
+      printf("%8x %8x %8x %8x\n", mask, a, b, result);
+      exit(1);
+    }
+
+  }
+
+  return 0;
+}
+
--- valgrind-3.3.0/none/tests/ppc32/power6_bcmp.stderr.exp.jj	2008-03-03 09:58:59.000000000 +0100
+++ valgrind-3.3.0/none/tests/ppc32/power6_bcmp.stderr.exp	2008-03-03 09:58:59.000000000 +0100
@@ -0,0 +1,2 @@
+
+
--- valgrind-3.3.0/none/tests/ppc32/power6_bcmp.vgtest.jj	2008-03-03 09:58:59.000000000 +0100
+++ valgrind-3.3.0/none/tests/ppc32/power6_bcmp.vgtest	2008-03-03 09:58:59.000000000 +0100
@@ -0,0 +1 @@
+prog: power6_bcmp
--- valgrind-3.3.0/none/tests/ppc64/Makefile.am.jj	2007-12-11 00:18:35.000000000 +0100
+++ valgrind-3.3.0/none/tests/ppc64/Makefile.am	2008-03-03 10:01:52.000000000 +0100
@@ -9,10 +9,12 @@ EXTRA_DIST = $(noinst_SCRIPTS) \
 	std_reg_imm.vgtest std_reg_imm.stderr.exp std_reg_imm.stdout.exp \
 	round.stderr.exp round.stdout.exp round.vgtest \
 	twi_tdi.stderr.exp twi_tdi.stdout.exp twi_tdi.vgtest \
-	tw_td.stderr.exp tw_td.stdout.exp tw_td.vgtest
+	tw_td.stderr.exp tw_td.stdout.exp tw_td.vgtest \
+	power6_bcmp.stderr.exp power6_bcmp.stdout.exp power6_bcmp.vgtest \
+	power6_mf_gpr.stderr.exp power6_mf_gpr.stdout.exp power6_mf_gpr.vgtest
 
 check_PROGRAMS = \
-	jm-insns lsw round std_reg_imm twi_tdi tw_td
+	jm-insns lsw round std_reg_imm twi_tdi tw_td power6_bcmp power6_mf_gpr
 
 AM_CFLAGS   = $(WERROR) -Winline -Wall -Wshadow -g -I$(top_srcdir)/include \
 		@FLAG_M64@
--- valgrind-3.3.0/none/tests/ppc64/power6_bcmp.c.jj	2008-03-03 09:58:59.000000000 +0100
+++ valgrind-3.3.0/none/tests/ppc64/power6_bcmp.c	2008-03-03 09:58:59.000000000 +0100
@@ -0,0 +1,61 @@
+/*  Copyright (C) 2007  Pete Eberlein  eberlein@us.ibm.com
+
+    This program is free software; you can redistribute it and/or
+    modify it under the terms of the GNU General Public License as
+    published by the Free Software Foundation; either version 2 of the
+    License, or (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307, USA.
+
+    The GNU General Public License is contained in the file COPYING.
+*/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+
+#define CMPB(result,a,b) \
+    asm ("cmpb %0, %1, %2\n" : "=r"(result) : "r"(a), "r"(b))
+
+
+int main (int argc, char* argv[]) {
+  int i,j,k;
+  unsigned long mask;
+  for (i=1; i<256; i++) {
+   mask = 0;
+   if(i&1) mask+=0xff;
+   if(i&2) mask+=0xff00;
+   if(i&4) mask+=0xff0000;
+   if(i&8) mask+=0xff000000;
+   if(i&16) mask+=0xff00000000;
+   if(i&32) mask+=0xff0000000000;
+   if(i&64) mask+=0xff000000000000;
+   if(i&128) mask+=0xff00000000000000;
+
+   for (j=0; j<256; j++)
+    for (k=0; k<256; k++)
+      if (j!=k) {
+
+    unsigned long a, b, result;
+    a = (mask & (j*0x101010101010101)) + ((~mask) & (k*0x101010101010101));
+    b = j*0x101010101010101;
+    CMPB(result, a, b);
+    if (result != mask)
+      printf("%8lx %8lx %8lx %8lx\n", mask, a, b, result);
+      exit(1);
+    }
+
+  }
+
+  return 0;
+}
+
--- valgrind-3.3.0/none/tests/ppc64/power6_bcmp.stderr.exp.jj	2008-03-03 09:58:59.000000000 +0100
+++ valgrind-3.3.0/none/tests/ppc64/power6_bcmp.stderr.exp	2008-03-03 09:58:59.000000000 +0100
@@ -0,0 +1,2 @@
+
+
--- valgrind-3.3.0/none/tests/ppc64/power6_bcmp.vgtest.jj	2008-03-03 09:58:59.000000000 +0100
+++ valgrind-3.3.0/none/tests/ppc64/power6_bcmp.vgtest	2008-03-03 09:58:59.000000000 +0100
@@ -0,0 +1 @@
+prog: power6_bcmp
--- valgrind-3.3.0/none/tests/ppc64/power6_mf_gpr.c.jj	2008-03-03 09:58:59.000000000 +0100
+++ valgrind-3.3.0/none/tests/ppc64/power6_mf_gpr.c	2008-03-03 09:58:59.000000000 +0100
@@ -0,0 +1,47 @@
+/*  Copyright (C) 2007  Pete Eberlein  eberlein@us.ibm.com
+
+    This program is free software; you can redistribute it and/or
+    modify it under the terms of the GNU General Public License as
+    published by the Free Software Foundation; either version 2 of the
+    License, or (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307, USA.
+
+    The GNU General Public License is contained in the file COPYING.
+*/
+
+#include <stdio.h>
+#include <string.h>
+
+
+
+int main (int argc, char* argv[]) 
+{
+
+  long i;
+  double f;
+
+  i = 0;
+  f = 100.0;
+
+  printf("%lx %f\n", i, f);
+
+  asm ("mftgpr %0, %1\n" : "=r"(i) : "f"(f));
+
+  f=0.0;
+  printf("%lx %f\n", i, f);
+
+  asm ("mffgpr %0, %1\n" : "=f"(f) : "r"(i));
+
+  printf("%lx %f\n", i, f);
+
+  return 0;
+}
--- valgrind-3.3.0/none/tests/ppc64/power6_mf_gpr.stderr.exp.jj	2008-03-03 09:58:59.000000000 +0100
+++ valgrind-3.3.0/none/tests/ppc64/power6_mf_gpr.stderr.exp	2008-03-03 09:58:59.000000000 +0100
@@ -0,0 +1,2 @@
+
+
--- valgrind-3.3.0/none/tests/ppc64/power6_mf_gpr.stdout.exp.jj	2008-03-03 09:58:59.000000000 +0100
+++ valgrind-3.3.0/none/tests/ppc64/power6_mf_gpr.stdout.exp	2008-03-03 09:58:59.000000000 +0100
@@ -0,0 +1,3 @@
+0 100.000000
+4059000000000000 0.000000
+4059000000000000 100.000000
--- valgrind-3.3.0/none/tests/ppc64/power6_mf_gpr.vgtest.jj	2008-03-03 09:58:59.000000000 +0100
+++ valgrind-3.3.0/none/tests/ppc64/power6_mf_gpr.vgtest	2008-03-03 09:58:59.000000000 +0100
@@ -0,0 +1 @@
+prog: power6_mf_gpr
--- valgrind-3.3.0/none/tests/ppc32/Makefile.in.jj	2007-12-11 00:23:53.000000000 +0100
+++ valgrind-3.3.0/none/tests/ppc32/Makefile.in	2008-03-03 10:02:14.000000000 +0100
@@ -40,7 +40,8 @@ check_PROGRAMS = bug129390-ppc32$(EXEEXT
 	ldstrev$(EXEEXT) lsw$(EXEEXT) jm-insns$(EXEEXT) \
 	mftocrf$(EXEEXT) mcrfs$(EXEEXT) round$(EXEEXT) \
 	test_fx$(EXEEXT) test_gx$(EXEEXT) testVMX$(EXEEXT) \
-	twi$(EXEEXT) tw$(EXEEXT) xlc_dbl_u32$(EXEEXT)
+	twi$(EXEEXT) tw$(EXEEXT) xlc_dbl_u32$(EXEEXT) \
+	power5+_round$(EXEEXT) power6_bcmp$(EXEEXT)
 subdir = none/tests/ppc32
 DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
@@ -71,6 +72,12 @@ mcrfs_LDADD = $(LDADD)
 mftocrf_SOURCES = mftocrf.c
 mftocrf_OBJECTS = mftocrf.$(OBJEXT)
 mftocrf_LDADD = $(LDADD)
+power5__round_SOURCES = power5+_round.c
+power5__round_OBJECTS = power5+_round.$(OBJEXT)
+power5__round_LDADD = $(LDADD)
+power6_bcmp_SOURCES = power6_bcmp.c
+power6_bcmp_OBJECTS = power6_bcmp.$(OBJEXT)
+power6_bcmp_LDADD = $(LDADD)
 round_SOURCES = round.c
 round_OBJECTS = round.$(OBJEXT)
 round_LDADD = $(LDADD)
@@ -101,11 +108,12 @@ COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUD
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 SOURCES = bug129390-ppc32.c bug139050-ppc32.c jm-insns.c ldstrev.c \
-	lsw.c mcrfs.c mftocrf.c round.c testVMX.c test_fx.c test_gx.c \
-	tw.c twi.c xlc_dbl_u32.c
+	lsw.c mcrfs.c mftocrf.c power5+_round.c power6_bcmp.c round.c \
+	testVMX.c test_fx.c test_gx.c tw.c twi.c xlc_dbl_u32.c
 DIST_SOURCES = bug129390-ppc32.c bug139050-ppc32.c jm-insns.c \
-	ldstrev.c lsw.c mcrfs.c mftocrf.c round.c testVMX.c test_fx.c \
-	test_gx.c tw.c twi.c xlc_dbl_u32.c
+	ldstrev.c lsw.c mcrfs.c mftocrf.c power5+_round.c \
+	power6_bcmp.c round.c testVMX.c test_fx.c test_gx.c tw.c twi.c \
+	xlc_dbl_u32.c
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
@@ -266,7 +275,9 @@ EXTRA_DIST = $(noinst_SCRIPTS) \
 	testVMX.stderr.exp  testVMX.stdout.exp  testVMX.vgtest \
 	twi.stderr.exp twi.stdout.exp twi.vgtest \
 	tw.stderr.exp tw.stdout.exp tw.vgtest \
-	xlc_dbl_u32.stderr.exp xlc_dbl_u32.stdout.exp xlc_dbl_u32.vgtest
+	xlc_dbl_u32.stderr.exp xlc_dbl_u32.stdout.exp xlc_dbl_u32.vgtest \
+	power5+_round.stderr.exp power5+_round.stdout.exp power5+_round.vgtest \
+	power6_bcmp.stderr.exp power6_bcmp.stdout.exp power6_bcmp.vgtest
 
 AM_CFLAGS = $(WERROR) -Winline -Wall -Wshadow -g -I$(top_srcdir)/include \
 		@FLAG_M32@
@@ -335,6 +346,12 @@ mcrfs$(EXEEXT): $(mcrfs_OBJECTS) $(mcrfs
 mftocrf$(EXEEXT): $(mftocrf_OBJECTS) $(mftocrf_DEPENDENCIES) 
 	@rm -f mftocrf$(EXEEXT)
 	$(LINK) $(mftocrf_LDFLAGS) $(mftocrf_OBJECTS) $(mftocrf_LDADD) $(LIBS)
+power5+_round$(EXEEXT): $(power5__round_OBJECTS) $(power5__round_DEPENDENCIES) 
+	@rm -f power5+_round$(EXEEXT)
+	$(LINK) $(power5__round_LDFLAGS) $(power5__round_OBJECTS) $(power5__round_LDADD) $(LIBS)
+power6_bcmp$(EXEEXT): $(power6_bcmp_OBJECTS) $(power6_bcmp_DEPENDENCIES) 
+	@rm -f power6_bcmp$(EXEEXT)
+	$(LINK) $(power6_bcmp_LDFLAGS) $(power6_bcmp_OBJECTS) $(power6_bcmp_LDADD) $(LIBS)
 round$(EXEEXT): $(round_OBJECTS) $(round_DEPENDENCIES) 
 	@rm -f round$(EXEEXT)
 	$(LINK) $(round_LDFLAGS) $(round_OBJECTS) $(round_LDADD) $(LIBS)
@@ -370,6 +387,8 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsw.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcrfs.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mftocrf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/power5+_round.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/power6_bcmp.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/round.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testVMX-testVMX.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_fx.Po@am__quote@
--- valgrind-3.3.0/none/tests/ppc64/Makefile.in.jj	2007-12-11 00:23:55.000000000 +0100
+++ valgrind-3.3.0/none/tests/ppc64/Makefile.in	2008-03-03 10:02:14.000000000 +0100
@@ -37,7 +37,8 @@ POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 check_PROGRAMS = jm-insns$(EXEEXT) lsw$(EXEEXT) round$(EXEEXT) \
-	std_reg_imm$(EXEEXT) twi_tdi$(EXEEXT) tw_td$(EXEEXT)
+	std_reg_imm$(EXEEXT) twi_tdi$(EXEEXT) tw_td$(EXEEXT) \
+	power6_bcmp$(EXEEXT) power6_mf_gpr$(EXEEXT)
 subdir = none/tests/ppc64
 DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
@@ -53,6 +54,12 @@ jm_insns_LDADD = $(LDADD)
 lsw_SOURCES = lsw.c
 lsw_OBJECTS = lsw.$(OBJEXT)
 lsw_LDADD = $(LDADD)
+power6_bcmp_SOURCES = power6_bcmp.c
+power6_bcmp_OBJECTS = power6_bcmp.$(OBJEXT)
+power6_bcmp_LDADD = $(LDADD)
+power6_mf_gpr_SOURCES = power6_mf_gpr.c
+power6_mf_gpr_OBJECTS = power6_mf_gpr.$(OBJEXT)
+power6_mf_gpr_LDADD = $(LDADD)
 round_SOURCES = round.c
 round_OBJECTS = round.$(OBJEXT)
 round_LDADD = $(LDADD)
@@ -73,9 +80,10 @@ COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUD
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-SOURCES = jm-insns.c lsw.c round.c std_reg_imm.c tw_td.c twi_tdi.c
-DIST_SOURCES = jm-insns.c lsw.c round.c std_reg_imm.c tw_td.c \
-	twi_tdi.c
+SOURCES = jm-insns.c lsw.c power6_bcmp.c power6_mf_gpr.c round.c \
+	std_reg_imm.c tw_td.c twi_tdi.c
+DIST_SOURCES = jm-insns.c lsw.c power6_bcmp.c power6_mf_gpr.c round.c \
+	std_reg_imm.c tw_td.c twi_tdi.c
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
@@ -226,7 +235,9 @@ EXTRA_DIST = $(noinst_SCRIPTS) \
 	std_reg_imm.vgtest std_reg_imm.stderr.exp std_reg_imm.stdout.exp \
 	round.stderr.exp round.stdout.exp round.vgtest \
 	twi_tdi.stderr.exp twi_tdi.stdout.exp twi_tdi.vgtest \
-	tw_td.stderr.exp tw_td.stdout.exp tw_td.vgtest
+	tw_td.stderr.exp tw_td.stdout.exp tw_td.vgtest \
+	power6_bcmp.stderr.exp power6_bcmp.stdout.exp power6_bcmp.vgtest \
+	power6_mf_gpr.stderr.exp power6_mf_gpr.stdout.exp power6_mf_gpr.vgtest
 
 AM_CFLAGS = $(WERROR) -Winline -Wall -Wshadow -g -I$(top_srcdir)/include \
 		@FLAG_M64@
@@ -277,6 +288,12 @@ jm-insns$(EXEEXT): $(jm_insns_OBJECTS) $
 lsw$(EXEEXT): $(lsw_OBJECTS) $(lsw_DEPENDENCIES) 
 	@rm -f lsw$(EXEEXT)
 	$(LINK) $(lsw_LDFLAGS) $(lsw_OBJECTS) $(lsw_LDADD) $(LIBS)
+power6_bcmp$(EXEEXT): $(power6_bcmp_OBJECTS) $(power6_bcmp_DEPENDENCIES) 
+	@rm -f power6_bcmp$(EXEEXT)
+	$(LINK) $(power6_bcmp_LDFLAGS) $(power6_bcmp_OBJECTS) $(power6_bcmp_LDADD) $(LIBS)
+power6_mf_gpr$(EXEEXT): $(power6_mf_gpr_OBJECTS) $(power6_mf_gpr_DEPENDENCIES) 
+	@rm -f power6_mf_gpr$(EXEEXT)
+	$(LINK) $(power6_mf_gpr_LDFLAGS) $(power6_mf_gpr_OBJECTS) $(power6_mf_gpr_LDADD) $(LIBS)
 round$(EXEEXT): $(round_OBJECTS) $(round_DEPENDENCIES) 
 	@rm -f round$(EXEEXT)
 	$(LINK) $(round_LDFLAGS) $(round_OBJECTS) $(round_LDADD) $(LIBS)
@@ -298,6 +315,8 @@ distclean-compile:
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/jm_insns-jm-insns.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsw.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/power6_bcmp.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/power6_mf_gpr.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/round.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/std_reg_imm.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tw_td.Po@am__quote@
