commit 4e8ca2298aa12f10a40134f0aac161954597952e
Author: sewardj <sewardj@a5019735-40e9-0310-863c-91ae7b9d1cf9>
Date:   Thu May 15 16:47:56 2014 +0000

    Enable: sys_add_key, sys_keyctl, apparently needed by glibc-2.19.90 on
    arm64-linux.
    
    
    git-svn-id: svn://svn.valgrind.org/valgrind/trunk@13972 a5019735-40e9-0310-863c-91ae7b9d1cf9

diff --git a/coregrind/m_syswrap/syswrap-arm64-linux.c b/coregrind/m_syswrap/syswrap-arm64-linux.c
index b82b06b..c6de921 100644
--- a/coregrind/m_syswrap/syswrap-arm64-linux.c
+++ b/coregrind/m_syswrap/syswrap-arm64-linux.c
@@ -1024,6 +1024,8 @@ static SyscallTableEntry syscall_main_table[] = {
    GENX_(__NR_brk,               sys_brk),               // 214
    GENXY(__NR_munmap,            sys_munmap),            // 215
    GENX_(__NR_mremap,            sys_mremap),            // 216
+   LINX_(__NR_add_key,           sys_add_key),           // 217
+   LINXY(__NR_keyctl,            sys_keyctl),            // 219
    PLAX_(__NR_clone,             sys_clone),             // 220
    GENX_(__NR_execve,            sys_execve),            // 221
 
@@ -1342,9 +1344,7 @@ static SyscallTableEntry syscall_main_table[] = {
 //ZZ    LINXY(__NR_msgrcv,            sys_msgrcv),         
 //ZZ    LINXY(__NR_msgctl,            sys_msgctl),         // 304
 //ZZ 
-//ZZ    LINX_(__NR_add_key,           sys_add_key),        // 286
 //ZZ    LINX_(__NR_request_key,       sys_request_key),    // 287
-//ZZ    LINXY(__NR_keyctl,            sys_keyctl),         // not 288...
 //ZZ //   LINX_(__NR_ioprio_set,        sys_ioprio_set),     // 289
 //ZZ 
 //ZZ //   LINX_(__NR_ioprio_get,        sys_ioprio_get),     // 290
commit e013b24c6f62fda9836f5b0378573f1f7923ec8a
Author: sewardj <sewardj@8f6e269a-dfd6-0310-a8e1-e2731360e62c>
Date:   Thu May 15 16:49:21 2014 +0000

    Initial front-end fixings needed to handle code generated by gcc-4.9
    on arm64-linux.
    
    
    git-svn-id: svn://svn.valgrind.org/vex/trunk@2862 8f6e269a-dfd6-0310-a8e1-e2731360e62c

diff --git a/VEX/priv/guest_arm64_toIR.c b/VEX/priv/guest_arm64_toIR.c
index 862eb20..85b2f2d 100644
--- a/VEX/priv/guest_arm64_toIR.c
+++ b/VEX/priv/guest_arm64_toIR.c
@@ -1004,6 +1004,8 @@ static IRExpr* getQRegLO ( UInt qregNo, IRType ty )
 {
    Int off = offsetQRegLane(qregNo, ty, 0);
    switch (ty) {
+      case Ity_I8:
+      case Ity_I16:
       case Ity_I32: case Ity_I64:
       case Ity_F32: case Ity_F64: case Ity_V128:
          break;
@@ -7102,6 +7104,20 @@ Bool dis_ARM64_simd_and_fp(/*MB_OUT*/DisResult* dres, UInt insn)
       /* else it's really an ORR; fall through. */
    }
 
+   /* ---------------- CMEQ_d_d_#0 ---------------- */
+   /* 
+      010 11110 11 10000 0100 110 n d
+   */
+   if ((INSN(31,0) & 0xFFFFFC00) == 0x5EE09800) {
+      UInt nn = INSN(9,5);
+      UInt dd = INSN(4,0);
+      putQReg128(dd, unop(Iop_ZeroHI64ofV128,
+                          binop(Iop_CmpEQ64x2, getQReg128(nn),
+                                mkV128(0x0000))));
+      DIP("cmeq d%u, d%u, #0\n", dd, nn);
+      return True;
+   }
+
    vex_printf("ARM64 front end: simd_and_fp\n");
    return False;
 #  undef INSN
commit 5a75f1c5aad7e96a7f785fc05afecec96fab8166
Author: sewardj <sewardj@8f6e269a-dfd6-0310-a8e1-e2731360e62c>
Date:   Fri May 16 11:20:07 2014 +0000

    Implement SHL_d_d_#imm.
    
    
    git-svn-id: svn://svn.valgrind.org/vex/trunk@2863 8f6e269a-dfd6-0310-a8e1-e2731360e62c

diff --git a/VEX/priv/guest_arm64_toIR.c b/VEX/priv/guest_arm64_toIR.c
index 85b2f2d..25659b8 100644
--- a/VEX/priv/guest_arm64_toIR.c
+++ b/VEX/priv/guest_arm64_toIR.c
@@ -7106,7 +7106,7 @@ Bool dis_ARM64_simd_and_fp(/*MB_OUT*/DisResult* dres, UInt insn)
 
    /* ---------------- CMEQ_d_d_#0 ---------------- */
    /* 
-      010 11110 11 10000 0100 110 n d
+      010 11110 11 10000 0100 110 n d   CMEQ Dd, Dn, #0
    */
    if ((INSN(31,0) & 0xFFFFFC00) == 0x5EE09800) {
       UInt nn = INSN(9,5);
@@ -7118,6 +7118,22 @@ Bool dis_ARM64_simd_and_fp(/*MB_OUT*/DisResult* dres, UInt insn)
       return True;
    }
 
+   /* ---------------- SHL_d_d_#imm ---------------- */
+   /* 31         22 21  18 15     9 4
+      010 111110 1  ih3 ib 010101 n d  SHL Dd, Dn, #(ih3:ib)
+   */
+   if (INSN(31,22) == BITS10(0,1,0,1,1,1,1,1,0,1)
+       && INSN(15,10) == BITS6(0,1,0,1,0,1)) {
+      UInt nn = INSN(9,5);
+      UInt dd = INSN(4,0);
+      UInt sh = INSN(21,16);
+      vassert(sh < 64);
+      putQReg128(dd, unop(Iop_ZeroHI64ofV128,
+                          binop(Iop_ShlN64x2, getQReg128(nn), mkU8(sh))));
+      DIP("shl d%u, d%u, #%u\n", dd, nn, sh);
+      return True;
+   }
+
    vex_printf("ARM64 front end: simd_and_fp\n");
    return False;
 #  undef INSN
diff --git a/VEX/priv/host_arm64_isel.c b/VEX/priv/host_arm64_isel.c
index eb06cdf..470df6b 100644
--- a/VEX/priv/host_arm64_isel.c
+++ b/VEX/priv/host_arm64_isel.c
@@ -5543,10 +5543,14 @@ static HReg iselV128Expr_wrk ( ISelEnv* env, IRExpr* e )
                   default:
                      vassert(0);
                }
-               if (op != ARM64vecsh_INVALID && amt > 0 && amt <= limit) {
+               if (op != ARM64vecsh_INVALID && amt >= 0 && amt <= limit) {
                   HReg src = iselV128Expr(env, argL);
                   HReg dst = newVRegV(env);
-                  addInstr(env, ARM64Instr_VShiftImmV(op, dst, src, amt));
+                  if (amt > 0) {
+                     addInstr(env, ARM64Instr_VShiftImmV(op, dst, src, amt));
+                  } else {
+                     dst = src;
+                  }
                   return dst;
                }
             }
