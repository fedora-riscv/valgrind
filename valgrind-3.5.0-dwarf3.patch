--- valgrind/coregrind/m_debuginfo/priv_d3basics.h.jj	2009-10-09 12:52:05.000000000 +0200
+++ valgrind/coregrind/m_debuginfo/priv_d3basics.h	2009-10-13 14:55:12.000000000 +0200
@@ -522,6 +522,9 @@ typedef enum
     DW_OP_form_tls_address = 0x9b,
     DW_OP_call_frame_cfa = 0x9c,
     DW_OP_bit_piece = 0x9d,
+    /* DWARF 4 extensions.  */
+    DW_OP_implicit_value = 0x9e,
+    DW_OP_stack_value = 0x9f,
     /* GNU extensions.  */
     DW_OP_GNU_push_tls_address = 0xe0,
     /* HP extensions.  */
@@ -596,12 +599,13 @@ typedef
 
 /* This describes the result of evaluating a DWARF3 expression.
    GXR_Failure: failed; .word is an asciiz string summarising why
+   GXR_Addr:    evaluated to an address of the object, in .word
    GXR_Value:   evaluated to a value, in .word
    GXR_RegNo:   evaluated to a DWARF3 register number, in .word
 */
 typedef
    struct { 
-      enum { GXR_Failure, GXR_Value, GXR_RegNo } kind;
+      enum { GXR_Failure, GXR_Addr, GXR_Value, GXR_RegNo } kind;
       UWord word;
    }
    GXResult;
@@ -644,6 +648,10 @@ GXResult ML_(evaluate_Dwarf3_Expr) ( UCh
    covered by the guard is also ignored. */
 GXResult ML_(evaluate_trivial_GX)( GExpr* gx, const DebugInfo* di );
 
+/* Compute CFA for IP/SP/FP.  */
+Addr ML_(get_CFA) (Addr ip, Addr sp, Addr fp,
+                   Addr min_accessible, Addr max_accessible);
+
 #endif /* ndef __PRIV_D3BASICS_H */
 
 /*--------------------------------------------------------------------*/
--- valgrind/coregrind/m_debuginfo/d3basics.c.jj	2009-10-09 12:52:05.000000000 +0200
+++ valgrind/coregrind/m_debuginfo/d3basics.c	2009-10-13 14:54:40.000000000 +0200
@@ -443,7 +443,7 @@ static Bool bias_address( Addr* a, const
 
 
 /* Evaluate a standard DWARF3 expression.  See detailed description in
-   priv_d3basics.h. */
+   priv_d3basics.h.  Doesn't handle DW_OP_piece/DW_OP_bit_piece yet.  */
 GXResult ML_(evaluate_Dwarf3_Expr) ( UChar* expr, UWord exprszB, 
                                      GExpr* fbGX, RegSummary* regs,
                                      const DebugInfo* di,
@@ -482,8 +482,8 @@ GXResult ML_(evaluate_Dwarf3_Expr) ( UCh
    Addr     stack[N_EXPR_STACK]; /* stack of addresses, as per D3 spec */
    GXResult fbval, res;
    Addr     a1;
-   Word     sw1;
-   UWord    uw1;
+   Word     sw1, sw2;
+   UWord    uw1, uw2;
    Bool     ok;
 
    sp = -1;
@@ -568,12 +568,15 @@ GXResult ML_(evaluate_Dwarf3_Expr) ( UCh
             switch (fbval.kind) {
                case GXR_Failure:
                   return fbval; /* propagate failure */
-               case GXR_Value:
+               case GXR_Addr:
                   a1 = fbval.word; break; /* use as-is */
                case GXR_RegNo:
                   ok = get_Dwarf_Reg( &a1, fbval.word, regs );
                   if (!ok) return fbval; /* propagate failure */
                   break;
+               case GXR_Value:
+                  FAIL("evaluate_Dwarf3_Expr: DW_OP_{implicit,stack}_value "
+                       "in DW_AT_frame_base");
                default:
                   vg_assert(0);
             }
@@ -599,11 +602,23 @@ GXResult ML_(evaluate_Dwarf3_Expr) ( UCh
             a1 += sw1;
             PUSH( a1 );
             break;
+         case DW_OP_bregx:
+            if (!regs)
+               FAIL("evaluate_Dwarf3_Expr: DW_OP_breg* but no reg info");
+            a1 = 0;
+            uw1 = (UWord)read_leb128U( &expr );
+            if (!get_Dwarf_Reg( &a1, uw1, regs ))
+               FAIL("evaluate_Dwarf3_Expr: unhandled DW_OP_bregx reg value");
+            sw1 = (Word)read_leb128S( &expr );
+            a1 += sw1;
+            PUSH( a1 );
+            break;
          /* As per comment on DW_OP_breg*, the following denote that
             the value in question is in a register, not in memory.  So
             we simply return failure. (iow, the expression is
             malformed). */
          case DW_OP_reg0 ... DW_OP_reg31:
+         case DW_OP_regx:
             FAIL("evaluate_Dwarf3_Expr: DW_OP_reg* "
                  "whilst evaluating for a value");
             break;
@@ -637,6 +652,297 @@ GXResult ML_(evaluate_Dwarf3_Expr) ( UCh
                     "address not valid for client");
             }
             break;
+         case DW_OP_deref_size:
+            POP(uw1);
+            uw2 = *expr++;
+            if (VG_(am_is_valid_for_client)( (Addr)uw1, uw2,
+                                             VKI_PROT_READ )) {
+               switch (uw2) {
+                 case 1: uw1 = *(UChar*)uw1; break;
+                 case 2: uw1 = *(UShort*)uw1; break;
+                 case 4: uw1 = *(UInt*)uw1; break;
+                 case 8: uw1 = *(ULong*)uw1; break;
+                 default:
+                    FAIL("warning: evaluate_Dwarf3_Expr: unhandled "
+                         "DW_OP_deref_size size");
+               }
+               PUSH(uw1);
+            } else {
+               FAIL("warning: evaluate_Dwarf3_Expr: DW_OP_deref_size: "
+                    "address not valid for client");
+            }
+            break;
+         case DW_OP_lit0 ... DW_OP_lit31:
+            PUSH(opcode - DW_OP_lit0);
+            break;
+         case DW_OP_const1u:
+	    uw1 = *expr++;
+	    PUSH(uw1);
+            break;
+         case DW_OP_const2u:
+	    uw1 = *(UShort *)expr;
+	    expr += 2;
+	    PUSH(uw1);
+	    break;
+         case DW_OP_const4u:
+	    uw1 = *(UInt *)expr;
+	    expr += 4;
+	    PUSH(uw1);
+	    break;
+         case DW_OP_const8u:
+	    uw1 = *(ULong *)expr;
+	    expr += 8;
+	    PUSH(uw1);
+	    break;
+         case DW_OP_constu:
+            uw1 = read_leb128U( &expr );
+            PUSH(uw1);
+            break;
+         case DW_OP_const1s:
+	    uw1 = *(Char *) expr;
+	    expr++;
+	    PUSH(uw1);
+            break;
+         case DW_OP_const2s:
+	    uw1 = *(Short *)expr;
+	    expr += 2;
+	    PUSH(uw1);
+	    break;
+         case DW_OP_const4s:
+	    uw1 = *(Int *)expr;
+	    expr += 4;
+	    PUSH(uw1);
+	    break;
+         case DW_OP_const8s:
+	    uw1 = *(Long *)expr;
+	    expr += 8;
+	    PUSH(uw1);
+	    break;
+         case DW_OP_consts:
+            uw1 = read_leb128S( &expr );
+            PUSH(uw1);
+            break;
+         case DW_OP_dup:
+	    POP(uw1);
+	    PUSH(uw1);
+	    PUSH(uw1);
+	    break;
+	 case DW_OP_drop:
+	    POP(uw1);
+	    break;
+         case DW_OP_over:
+            uw1 = 1;
+            goto do_pick;
+	 case DW_OP_pick:
+	    uw1 = *expr++;
+         do_pick:
+            if (sp < (Int) uw1)
+               FAIL("evaluate_Dwarf3_Expr: stack underflow");
+            uw1 = stack[sp - uw1];
+            PUSH(uw1);
+            break;
+         case DW_OP_swap:
+            if (sp < 1)
+               FAIL("evaluate_Dwarf3_Expr: stack underflow");
+            uw1 = stack[sp];
+            stack[sp] = stack[sp - 1];
+            stack[sp - 1] = uw1;
+            break;
+         case DW_OP_rot:
+            if (sp < 2)
+               FAIL("evaluate_Dwarf3_Expr: stack underflow");
+            uw1 = stack[sp];
+            stack[sp] = stack[sp - 1];
+            stack[sp - 1] = stack[sp - 2];
+            stack[sp - 2] = uw1;
+            break;
+         case DW_OP_abs:
+            POP(sw1);
+            if (sw1 < 0)
+               sw1 = -sw1;
+            PUSH(sw1);
+            break;
+         case DW_OP_and:
+            POP(uw2);
+            POP(uw1);
+            uw1 &= uw2;
+            PUSH(uw1);
+            break;
+         case DW_OP_div:
+            POP(sw2);
+            if (sw2 == 0)
+               FAIL("evaluate_Dwarf3_Expr: division by zero");
+            POP(sw1);
+            sw1 /= sw2;
+            PUSH(sw1);
+            break;
+         case DW_OP_minus:
+            POP(uw2);
+            POP(uw1);
+            uw1 -= uw2;
+            PUSH(uw1);
+            break;
+         case DW_OP_mod:
+            POP(sw2);
+            if (sw2 == 0)
+               FAIL("evaluate_Dwarf3_Expr: division by zero");
+            POP(sw1);
+            sw1 %= sw2;
+            PUSH(sw1);
+            break;
+         case DW_OP_mul:
+            POP(uw2);
+            POP(uw1);
+            uw1 *= uw2;
+            PUSH(uw1);
+            break;
+         case DW_OP_neg:
+            POP(uw1);
+            uw1 = -uw1;
+            PUSH(uw1);
+            break;
+         case DW_OP_not:
+            POP(uw1);
+            uw1 = ~uw1;
+            PUSH(uw1);
+            break;
+         case DW_OP_or:
+            POP(uw2);
+            POP(uw1);
+            uw1 |= uw2;
+            PUSH(uw1);
+            break;
+         case DW_OP_plus:
+            POP(uw2);
+            POP(uw1);
+            uw1 += uw2;
+            PUSH(uw1);
+            break;
+         case DW_OP_shl:
+            POP(uw2);
+            POP(uw1);
+            uw1 <<= uw2;
+            PUSH(uw1);
+            break;
+         case DW_OP_shr:
+            POP(uw2);
+            POP(uw1);
+            uw1 >>= uw2;
+            PUSH(uw1);
+            break;
+         case DW_OP_shra:
+            POP(uw2);
+            POP(sw1);
+            sw1 >>= uw2;
+            PUSH(sw1);
+            break;
+         case DW_OP_xor:
+            POP(uw2);
+            POP(uw1);
+            uw1 ^= uw2;
+            PUSH(uw1);
+            break;
+         case DW_OP_le:
+            POP(sw2);
+            POP(sw1);
+            sw1 = sw1 <= sw2;
+            PUSH(sw1);
+            break;
+         case DW_OP_lt:
+            POP(sw2);
+            POP(sw1);
+            sw1 = sw1 < sw2;
+            PUSH(sw1);
+            break;
+         case DW_OP_ge:
+            POP(sw2);
+            POP(sw1);
+            sw1 = sw1 >= sw2;
+            PUSH(sw1);
+            break;
+         case DW_OP_gt:
+            POP(sw2);
+            POP(sw1);
+            sw1 = sw1 > sw2;
+            PUSH(sw1);
+            break;
+         case DW_OP_ne:
+            POP(sw2);
+            POP(sw1);
+            sw1 = sw1 != sw2;
+            PUSH(sw1);
+            break;
+         case DW_OP_eq:
+            POP(sw2);
+            POP(sw1);
+            sw1 = sw1 == sw2;
+            PUSH(sw1);
+            break;
+         case DW_OP_skip:
+            sw1 = *(Short *)expr;
+            expr += 2;
+            if (sw1 < 0 && expr < limit - exprszB - sw1)
+               FAIL("evaluate_Dwarf3_Expr: DW_OP_skip before start of expr");
+            expr += sw1;
+            break;
+         case DW_OP_bra:
+            sw1 = *(Short *)expr;
+            expr += 2;
+            if (sw1 < 0 && expr < limit - exprszB - sw1)
+               FAIL("evaluate_Dwarf3_Expr: DW_OP_bra before start of expr");
+            POP(uw1);
+            if (uw1)
+               expr += sw1;
+            break;
+         case DW_OP_nop:
+            break;
+         case DW_OP_call_frame_cfa:
+            if (!regs)
+               FAIL("evaluate_Dwarf3_Expr: DW_OP_call_frame_cfa but no reg info");
+            uw1 = ML_(get_CFA)(regs->ip, regs->sp, regs->fp, 0, ~(UWord) 0);
+            if (!uw1)
+               FAIL("evaluate_Dwarf3_Expr: Could not resolve "
+                    "DW_OP_call_frame_cfa");
+            PUSH(uw1);
+            break;
+         case DW_OP_implicit_value:
+            sw1 = (Word)read_leb128S( &expr );
+            uw1 = 0;
+            switch (sw1) {
+               case 1:
+                  uw1 = *(UChar *) expr;
+                  expr += 1;
+                  break;
+               case 2:
+                  uw1 = *(UShort *) expr;
+                  expr += 2;
+                  break;
+               case 4:
+                  uw1 = *(UInt *) expr;
+                  expr += 4;
+                  break;
+               case 8:
+                  uw1 = *(ULong *) expr;
+                  expr += 8;
+                  break;
+               default:
+                  FAIL("evaluate_Dwarf3_Expr: Unhandled "
+                       "DW_OP_implicit_value size");
+            }
+            if (expr != limit)
+               FAIL("evaluate_Dwarf3_Expr: DW_OP_implicit_value "
+                    "does not terminate expression");
+            res.word = uw1;
+            res.kind = GXR_Value;
+            return res;
+         case DW_OP_stack_value:
+            POP (uw1);
+            res.word = uw1;
+            res.kind = GXR_Value;
+            if (expr != limit)
+               FAIL("evaluate_Dwarf3_Expr: DW_OP_stack_value "
+                    "does not terminate expression");
+            break;
          default:
             if (!VG_(clo_xml))
                VG_(message)(Vg_DebugMsg, 
@@ -650,7 +956,7 @@ GXResult ML_(evaluate_Dwarf3_Expr) ( UCh
 
    vg_assert(sp >= 0 && sp < N_EXPR_STACK);
    res.word = stack[sp];
-   res.kind = GXR_Value;
+   res.kind = GXR_Addr;
    return res;
  
 #  undef POP
@@ -884,7 +1190,7 @@ GXResult ML_(evaluate_trivial_GX)( GExpr
 
    /* Well, we have success.  All subexpressions evaluated, and 
       they all agree.  Hurrah. */
-   res.kind = GXR_Value;
+   res.kind = GXR_Addr;
    res.word = (UWord)mul->ul; /* NB: narrowing from ULong */
    VG_(deleteXA)( results );
    return res;
@@ -896,6 +1202,8 @@ void ML_(pp_GXResult) ( GXResult res )
    switch (res.kind) {
       case GXR_Failure:
          VG_(printf)("GXR_Failure(%s)", (HChar*)res.word); break;
+      case GXR_Addr:
+         VG_(printf)("GXR_Addr(0x%lx)", res.word); break;
       case GXR_Value:
          VG_(printf)("GXR_Value(0x%lx)", res.word); break;
       case GXR_RegNo:
--- valgrind/coregrind/m_debuginfo/debuginfo.c.jj	2009-10-09 12:52:05.000000000 +0200
+++ valgrind/coregrind/m_debuginfo/debuginfo.c	2009-10-13 14:55:45.000000000 +0200
@@ -2003,6 +2003,62 @@ static void cfsi_cache__invalidate ( voi
 }
 
 
+Addr ML_(get_CFA) (Addr ip, Addr sp, Addr fp,
+                   Addr min_accessible, Addr max_accessible )
+{
+   Bool       ok;
+   DebugInfo* di;
+   DiCfSI*    cfsi = NULL;
+   Addr       cfa;
+   CfiExprEvalContext eec;
+   UWord hash = ip % N_CFSI_CACHE;
+   CFSICacheEnt* ce = &cfsi_cache[hash];
+
+   if (LIKELY(ce->ip == ip) && LIKELY(ce->di != NULL)) {
+      /* found an entry in the cache .. */
+   } else {
+      /* not found in cache.  Search and update. */
+      ce->ip = ip;
+      find_DiCfSI( &ce->di, &ce->ix, ip );
+   }
+
+   if (UNLIKELY(ce->di == (DebugInfo*)1)) {
+      /* no DiCfSI for this address */
+      return 0;
+   } else {
+      /* found a DiCfSI for this address */
+      di = ce->di;
+      cfsi = &di->cfsi[ ce->ix ];
+   }
+
+   if (UNLIKELY(cfsi == NULL))
+      return 0; /* no info.  Nothing we can do. */
+
+   /* Compute the CFA. */
+   cfa = 0;
+   switch (cfsi->cfa_how) {
+      case CFIC_SPREL: 
+         cfa = cfsi->cfa_off + sp;
+         break;
+      case CFIC_FPREL: 
+         cfa = cfsi->cfa_off + fp;
+         break;
+      case CFIC_EXPR: 
+         eec.ipHere = ip;
+         eec.spHere = sp;
+         eec.fpHere = fp;
+         eec.min_accessible = min_accessible;
+         eec.max_accessible = max_accessible;
+         ok = True;
+         cfa = evalCfiExpr(di->cfsi_exprs, cfsi->cfa_off, &eec, &ok );
+         if (!ok) return 0;
+         break;
+      default: 
+         vg_assert(0);
+   }
+   return cfa;
+}
+
 /* The main function for DWARF2/3 CFI-based stack unwinding.
    Given an IP/SP/FP triple, produce the IP/SP/FP values for the
    previous frame, if possible. */
@@ -2346,7 +2402,7 @@ static Bool data_address_is_in_var ( /*O
       VG_(printf)("\n");
    }
 
-   if (res.kind == GXR_Value 
+   if (res.kind == GXR_Addr 
        && res.word <= data_addr
        && data_addr < res.word + var_szB) {
       *offset = data_addr - res.word;
@@ -3057,7 +3113,7 @@ void analyse_deps ( /*MOD*/XArray* /* of
    vg_assert(res_sp_6k.kind == res_fp_6k.kind);
    vg_assert(res_sp_6k.kind == res_fp_7k.kind);
 
-   if (res_sp_6k.kind == GXR_Value) {
+   if (res_sp_6k.kind == GXR_Addr) {
       StackBlock block;
       GXResult res;
       UWord sp_delta = res_sp_7k.word - res_sp_6k.word;
@@ -3074,7 +3130,7 @@ void analyse_deps ( /*MOD*/XArray* /* of
          regs.sp = regs.fp = 0;
          regs.ip = ip;
          res = ML_(evaluate_GX)( var->gexpr, var->fbGX, &regs, di );
-         tl_assert(res.kind == GXR_Value);
+         tl_assert(res.kind == GXR_Addr);
          if (debug)
          VG_(printf)("   %5ld .. %5ld (sp) %s\n",
                      res.word, res.word + ((UWord)mul.ul) - 1, var->name);
@@ -3093,7 +3149,7 @@ void analyse_deps ( /*MOD*/XArray* /* of
          regs.sp = regs.fp = 0;
          regs.ip = ip;
          res = ML_(evaluate_GX)( var->gexpr, var->fbGX, &regs, di );
-         tl_assert(res.kind == GXR_Value);
+         tl_assert(res.kind == GXR_Addr);
          if (debug)
          VG_(printf)("   %5ld .. %5ld (FP) %s\n",
                      res.word, res.word + ((UWord)mul.ul) - 1, var->name);
@@ -3308,7 +3364,7 @@ void* /* really, XArray* of GlobalBlock 
             res = ML_(evaluate_trivial_GX)( var->gexpr, di );
 
             /* Not a constant address => not interesting */
-            if (res.kind != GXR_Value) {
+            if (res.kind != GXR_Addr) {
                if (0) VG_(printf)("FAIL\n");
                continue;
             }
--- valgrind/coregrind/m_debuginfo/tytypes.c.jj	2009-10-09 12:52:05.000000000 +0200
+++ valgrind/coregrind/m_debuginfo/tytypes.c	2009-10-13 13:52:57.000000000 +0200
@@ -766,7 +766,7 @@ XArray* /*UChar*/ ML_(describe_type)( /*
                   ML_(pp_GXResult)(res);
                   VG_(printf)("\n");
                }
-               if (res.kind != GXR_Value)
+               if (res.kind != GXR_Addr)
                   continue;
                mul = ML_(sizeOfType)( tyents, field->Te.Field.typeR );
                if (mul.b != True)
